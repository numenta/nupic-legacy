<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Classifiers &#8212; NuPIC 1.0.3.dev0

 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.3.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Anomaly Detection" href="anomaly-detection.html" />
    <link rel="prev" title="Sequence Memory" href="sequence-memory.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="classifiers">
<h1>Classifiers<a class="headerlink" href="#classifiers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-nupic.algorithms.sdr_classifier">
<span id="sdr-classifier"></span><h2>SDR Classifier<a class="headerlink" href="#module-nupic.algorithms.sdr_classifier" title="Permalink to this headline">¶</a></h2>
<p>Implementation of a SDR classifier.</p>
<p>The SDR classifier takes the form of a single layer classification network
that takes SDRs as input and outputs a predicted distribution of classes.</p>
<dl class="class">
<dt id="nupic.algorithms.sdr_classifier.SDRClassifier">
<em class="property">class </em><code class="descclassname">nupic.algorithms.sdr_classifier.</code><code class="descname">SDRClassifier</code><span class="sig-paren">(</span><em>steps=(1</em>, <em>)</em>, <em>alpha=0.001</em>, <em>actValueAlpha=0.3</em>, <em>verbosity=0</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier.SDRClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../support/index.html#nupic.serializable.Serializable" title="nupic.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">nupic.serializable.Serializable</span></code></a></p>
<p>The SDR Classifier accepts a binary input pattern from the
level below (the &#8220;activationPattern&#8221;) and information from the sensor and
encoders (the &#8220;classification&#8221;) describing the true (target) input.</p>
<p>The SDR classifier maps input patterns to class labels. There are as many
output units as the number of class labels or buckets (in the case of scalar
encoders). The output is a probabilistic distribution over all class labels.</p>
<p>During inference, the output is calculated by first doing a weighted summation
of all the inputs, and then perform a softmax nonlinear function to get
the predicted distribution of class labels</p>
<p>During learning, the connection weights between input units and output units
are adjusted to maximize the likelihood of the model</p>
<p>Example Usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">SDRClassifier</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">actValueAlpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">verbosity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># learning</span>
<span class="n">c</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">recordNum</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">patternNZ</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
          <span class="n">classification</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;bucketIdx&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;actValue&quot;</span><span class="p">:</span> <span class="mf">34.7</span><span class="p">},</span>
          <span class="n">learn</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">infer</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># inference</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">recordNum</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">patternNZ</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span>
                   <span class="n">classification</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;bucketIdx&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;actValue&quot;</span><span class="p">:</span> <span class="mf">34.7</span><span class="p">},</span>
                   <span class="n">learn</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">infer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Print the top three predictions for 1 steps out.</span>
<span class="n">topPredictions</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">result</span><span class="p">[</span><span class="s2">&quot;actualValues&quot;</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
<span class="k">for</span> <span class="n">probability</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">topPredictions</span><span class="p">:</span>
  <span class="k">print</span> <span class="s2">&quot;Prediction of {} has probability of {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span>
                                                         <span class="n">probability</span><span class="o">*</span><span class="mf">100.0</span><span class="p">)</span>
</pre></div>
</div>
<p>References:</p>
<ul class="simple">
<li>Alex Graves. Supervised Sequence Labeling with Recurrent Neural Networks,
PhD Thesis, 2008</li>
<li>J. S. Bridle. Probabilistic interpretation of feedforward classification
network outputs, with relationships to statistical pattern recognition</li>
<li>In F. Fogleman-Soulie and J.Herault, editors, Neurocomputing: Algorithms,
Architectures and Applications, pp 227-236, Springer-Verlag, 1990</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>steps</strong> &#8211; (list) Sequence of the different steps of multi-step predictions
to learn</li>
<li><strong>alpha</strong> &#8211; (float) The alpha used to adapt the weight matrix during
learning. A larger alpha results in faster adaptation to the data.</li>
<li><strong>actValueAlpha</strong> &#8211; (float) Used to track the actual value within each
bucket. A lower actValueAlpha results in longer term memory</li>
<li><strong>verbosity</strong> &#8211; (int) verbosity level, can be 0, 1, or 2</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">(ValueError) when record number does not increase monotonically.</p>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nupic.algorithms.sdr_classifier.SDRClassifier.compute">
<code class="descname">compute</code><span class="sig-paren">(</span><em>recordNum</em>, <em>patternNZ</em>, <em>classification</em>, <em>learn</em>, <em>infer</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier.SDRClassifier.compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Process one input sample.</p>
<p>This method is called by outer loop code outside the nupic-engine. We
use this instead of the nupic engine compute() because our inputs and
outputs aren&#8217;t fixed size vectors of reals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>recordNum</strong> &#8211; Record number of this input pattern. Record numbers
normally increase sequentially by 1 each time unless there are missing
records in the dataset. Knowing this information insures that we don&#8217;t get
confused by missing records.</li>
<li><strong>patternNZ</strong> &#8211; List of the active indices from the output below. When the
input is from TemporalMemory, this list should be the indices of the
active cells.</li>
<li><strong>classification</strong> &#8211; <p>Dict of the classification information where:</p>
<ul>
<li>bucketIdx: list of indices of the encoder bucket</li>
<li>actValue: list of actual values going into the encoder</li>
</ul>
<p>Classification could be None for inference mode.</p>
</li>
<li><strong>learn</strong> &#8211; (bool) if true, learn this sample</li>
<li><strong>infer</strong> &#8211; (bool) if true, perform inference</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>Dict containing inference results, there is one entry for each
step in self.steps, where the key is the number of steps, and
the value is an array containing the relative likelihood for
each bucketIdx starting from bucketIdx 0.</p>
<p>There is also an entry containing the average actual value to
use for each bucket. The key is &#8216;actualValues&#8217;.</p>
<p>for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span><span class="mi">1</span> <span class="p">:</span>             <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span>
  <span class="mi">4</span> <span class="p">:</span>             <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
  <span class="s1">&#39;actualValues&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="mf">7.6</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.sdr_classifier.SDRClassifier.infer">
<code class="descname">infer</code><span class="sig-paren">(</span><em>patternNZ</em>, <em>actValueList</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier.SDRClassifier.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inference value from one input sample. The actual
learning happens in compute().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>patternNZ</strong> &#8211; list of the active indices from the output below</li>
<li><strong>classification</strong> &#8211; dict of the classification information:
bucketIdx: index of the encoder bucket
actValue:  actual value going into the encoder</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>dict containing inference results, one entry for each step in
self.steps. The key is the number of steps, the value is an
array containing the relative likelihood for each bucketIdx
starting from bucketIdx 0.</p>
<p>for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;actualValues&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
  <span class="mi">1</span> <span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]</span>
  <span class="mi">4</span> <span class="p">:</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]}</span>
</pre></div>
</div>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.sdr_classifier.SDRClassifier.inferSingleStep">
<code class="descname">inferSingleStep</code><span class="sig-paren">(</span><em>patternNZ</em>, <em>weightMatrix</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier.SDRClassifier.inferSingleStep" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform inference for a single step. Given an SDR input and a weight
matrix, return a predicted distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>patternNZ</strong> &#8211; list of the active indices from the output below</li>
<li><strong>weightMatrix</strong> &#8211; numpy array of the weight matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">numpy array of the predicted class label distribution</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="nupic.algorithms.sdr_classifier_factory.SDRClassifierFactory">
<em class="property">class </em><code class="descclassname">nupic.algorithms.sdr_classifier_factory.</code><code class="descname">SDRClassifierFactory</code><a class="headerlink" href="#nupic.algorithms.sdr_classifier_factory.SDRClassifierFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory for instantiating SDR classifiers.</p>
<dl class="staticmethod">
<dt id="nupic.algorithms.sdr_classifier_factory.SDRClassifierFactory.create">
<em class="property">static </em><code class="descname">create</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.sdr_classifier_factory.SDRClassifierFactory.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a SDR classifier factory.
The implementation of the SDR Classifier can be specified with
the &#8220;implementation&#8221; keyword argument.</p>
<dl class="docutils">
<dt>The SDRClassifierFactory uses the implementation as specified in</dt>
<dd><a class="reference external" href="default-config.html">Default NuPIC Configuration</a>.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="knn-classifier">
<h2>KNN Classifier<a class="headerlink" href="#knn-classifier" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier">
<em class="property">class </em><code class="descclassname">nupic.algorithms.knn_classifier.</code><code class="descname">KNNClassifier</code><span class="sig-paren">(</span><em>k=1</em>, <em>exact=False</em>, <em>distanceNorm=2.0</em>, <em>distanceMethod='norm'</em>, <em>distThreshold=0</em>, <em>doBinarization=False</em>, <em>binarizationThreshold=0.5</em>, <em>useSparseMemory=True</em>, <em>sparseThreshold=0.1</em>, <em>relativeThreshold=False</em>, <em>numWinners=0</em>, <em>numSVDSamples=None</em>, <em>numSVDDims=None</em>, <em>fractionOfMax=None</em>, <em>verbosity=0</em>, <em>maxStoredPatterns=-1</em>, <em>replaceDuplicates=False</em>, <em>cellsPerCol=0</em>, <em>minSparsity=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="../support/index.html#nupic.serializable.Serializable" title="nupic.serializable.Serializable"><code class="xref py py-class docutils literal"><span class="pre">nupic.serializable.Serializable</span></code></a></p>
<p>This class implements NuPIC&#8217;s k Nearest Neighbor Classifier. KNN is very
useful as a basic classifier for many situations. This implementation contains
many enhancements that are useful for HTM experiments. These enhancements
include an optimized C++ class for sparse vectors, support for continuous
online learning, support for various distance methods (including Lp-norm and
raw overlap), support for performing SVD on the input vectors (very useful for
large vectors), support for a fixed-size KNN, and a mechanism to store custom
ID&#8217;s for each vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>k</strong> &#8211; (int) The number of nearest neighbors used in the classification
of patterns. Must be odd.</li>
<li><strong>exact</strong> &#8211; (boolean) If true, patterns must match exactly when assigning
class labels</li>
<li><strong>distanceNorm</strong> &#8211; (int) When distance method is &#8220;norm&#8221;, this specifies
the p value of the Lp-norm</li>
<li><strong>distanceMethod</strong> &#8211; <p>(string) The method used to compute distance between
input patterns and prototype patterns. The possible options are:</p>
<ul>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">norm</span></code>: When distanceNorm is 2, this is the euclidean distance,</dt>
<dd>When distanceNorm is 1, this is the manhattan distance
In general: sum(abs(x-proto) ^ distanceNorm) ^ (1/distanceNorm)
The distances are normalized such that farthest prototype from
a given input is 1.0.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">rawOverlap</span></code>: Only appropriate when inputs are binary. This computes:</dt>
<dd>(width of the input) - (# bits of overlap between input
and prototype).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">pctOverlapOfInput</span></code>: Only appropriate for binary inputs. This computes</dt>
<dd><dl class="first last docutils">
<dt>1.0 - (# bits overlap between input and prototype) /</dt>
<dd>(# ON bits in input)</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">pctOverlapOfProto</span></code>: Only appropriate for binary inputs. This computes</dt>
<dd><dl class="first last docutils">
<dt>1.0 - (# bits overlap between input and prototype) /</dt>
<dd>(# ON bits in prototype)</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">pctOverlapOfLarger</span></code>: Only appropriate for binary inputs. This computes</dt>
<dd><dl class="first last docutils">
<dt>1.0 - (# bits overlap between input and prototype) /</dt>
<dd>max(# ON bits in input, # ON bits in prototype)</dd>
</dl>
</dd>
</dl>
</li>
</ul>
</li>
<li><strong>distThreshold</strong> &#8211; (float) A threshold on the distance between learned
patterns and a new pattern proposed to be learned. The distance must be
greater than this threshold in order for the new pattern to be added to
the classifier&#8217;s memory.</li>
<li><strong>doBinarization</strong> &#8211; (boolean) If True, then scalar inputs will be
binarized.</li>
<li><strong>binarizationThreshold</strong> &#8211; (float) If doBinarization is True, this
specifies the threshold for the binarization of inputs</li>
<li><strong>useSparseMemory</strong> &#8211; (boolean) If True, classifier will use a sparse
memory matrix</li>
<li><strong>sparseThreshold</strong> &#8211; (float) If useSparseMemory is True, input variables
whose absolute values are less than this threshold will be stored as
zero</li>
<li><strong>relativeThreshold</strong> &#8211; (boolean) Flag specifying whether to multiply
sparseThreshold by max value in input</li>
<li><strong>numWinners</strong> &#8211; (int) Number of elements of the input that are stored. If
0, all elements are stored</li>
<li><strong>numSVDSamples</strong> &#8211; (int) Number of samples the must occur before a SVD
(Singular Value Decomposition) transformation will be performed. If 0,
the transformation will never be performed</li>
<li><strong>numSVDDims</strong> &#8211; (string) Controls dimensions kept after SVD
transformation. If &#8220;adaptive&#8221;, the number is chosen automatically</li>
<li><strong>fractionOfMax</strong> &#8211; (float) If numSVDDims is &#8220;adaptive&#8221;, this controls the
smallest singular value that is retained as a fraction of the largest
singular value</li>
<li><strong>verbosity</strong> &#8211; (int) Console verbosity level where 0 is no output and
larger integers provide increasing levels of verbosity</li>
<li><strong>maxStoredPatterns</strong> &#8211; (int) Limits the maximum number of the training
patterns stored. When KNN learns in a fixed capacity mode, the unused
patterns are deleted once the number of stored patterns is greater than
maxStoredPatterns. A value of -1 is no limit</li>
<li><strong>replaceDuplicates</strong> &#8211; (bool) A boolean flag that determines whether,
during learning, the classifier replaces duplicates that match exactly,
even if distThreshold is 0. Should be True for online learning</li>
<li><strong>cellsPerCol</strong> &#8211; (int) If &gt;= 1, input is assumed to be organized into
columns, in the same manner as the temporal memory AND whenever a new
prototype is stored, only the start cell (first cell) is stored in any
bursting column</li>
<li><strong>minSparsity</strong> &#8211; (float) If useSparseMemory is set, only vectors with
sparsity &gt;= minSparsity will be stored during learning. A value of 0.0
implies all vectors will be stored. A value of 0.1 implies only vectors
with at least 10% sparsity will be stored</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the state of the KNNClassifier.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.closestOtherTrainingPattern">
<code class="descname">closestOtherTrainingPattern</code><span class="sig-paren">(</span><em>inputPattern</em>, <em>cat</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.closestOtherTrainingPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the closest training pattern that is <em>not</em> of the given
category &#8220;cat&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputPattern</strong> &#8211; The pattern whose closest neighbor is sought</li>
<li><strong>cat</strong> &#8211; Training patterns of this category will be ignored no matter
their distance to inputPattern</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dense version of the closest training pattern, or None if no
such patterns exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.closestTrainingPattern">
<code class="descname">closestTrainingPattern</code><span class="sig-paren">(</span><em>inputPattern</em>, <em>cat</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.closestTrainingPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the closest training pattern to inputPattern that belongs to
category &#8220;cat&#8221;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputPattern</strong> &#8211; The pattern whose closest neighbor is sought</li>
<li><strong>cat</strong> &#8211; The required category of closest neighbor</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dense version of the closest training pattern, or None if no
such patterns exist</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.computeSVD">
<code class="descname">computeSVD</code><span class="sig-paren">(</span><em>numSVDSamples=None</em>, <em>finalize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.computeSVD" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the singular value decomposition (SVD). The SVD is a factorization
of a real or complex matrix. It factors the matrix <cite>a</cite> as
<cite>u * np.diag(s) * v</cite>, where <cite>u</cite> and <cite>v</cite> are unitary and <cite>s</cite> is a 1-d array
of <cite>a</cite>&#8216;s singular values.</p>
<p><strong>Reason for computing the SVD:</strong></p>
<p>There are cases where you want to feed a lot of vectors to the
KNNClassifier. However, this can be slow. You can speed up training by (1)
computing the SVD of the input patterns which will give you the
eigenvectors, (2) only keeping a fraction of the eigenvectors, and (3)
projecting the input patterns onto the remaining eigenvectors.</p>
<p>Note that all input patterns are projected onto the eigenvectors in the same
fashion. Keeping only the highest eigenvectors increases training
performance since it reduces the dimensionality of the input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>numSVDSamples</strong> &#8211; (int) the number of samples to use for the SVD
computation.</li>
<li><strong>finalize</strong> &#8211; (bool) whether to apply SVD to the input patterns.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(array) The singular values for every matrix, sorted in
descending order.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.doIteration">
<code class="descname">doIteration</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.doIteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility method to increment the iteration index. Intended for models that
don&#8217;t learn each timestep.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.finishLearning">
<code class="descname">finishLearning</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.finishLearning" title="Permalink to this definition">¶</a></dt>
<dd><p>Used for batch scenarios.  This method needs to be called between learning
and inference.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getAdaptiveSVDDims">
<code class="descname">getAdaptiveSVDDims</code><span class="sig-paren">(</span><em>singularValues</em>, <em>fractionOfMax=0.001</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getAdaptiveSVDDims" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the number of eigenvectors (singularValues) to keep.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>singularValues</strong> &#8211; </li>
<li><strong>fractionOfMax</strong> &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getClosest">
<code class="descname">getClosest</code><span class="sig-paren">(</span><em>inputPattern</em>, <em>topKCategories=3</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getClosest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the pattern that is closest to inputPattern,
the distances of all patterns to inputPattern, and the indices of the k
closest categories.</p>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getDistances">
<code class="descname">getDistances</code><span class="sig-paren">(</span><em>inputPattern</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the distances between the input pattern and all other
stored patterns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputPattern</strong> &#8211; pattern to check distance with</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(distances, categories) numpy arrays of the same length.
- overlaps: an integer overlap amount for each category
- categories: category index for each element of distances</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getNumPartitionIds">
<code class="descname">getNumPartitionIds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getNumPartitionIds" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the number of unique partition Ids stored.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getOverlaps">
<code class="descname">getOverlaps</code><span class="sig-paren">(</span><em>inputPattern</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getOverlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the degree of overlap between an input pattern and each category
stored in the classifier. The overlap is computed by computing:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">logical_and</span><span class="p">(</span><span class="n">inputPattern</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trainingPattern</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputPattern</strong> &#8211; pattern to check overlap of</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(overlaps, categories) Two numpy arrays of the same length, where:<ul class="simple">
<li>overlaps: an integer overlap amount for each category</li>
<li>categories: category index for each element of overlaps</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getPartitionId">
<code class="descname">getPartitionId</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getPartitionId" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the partition id given an index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> &#8211; index of partition</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the partition id associated with pattern i. Returns None if no id
is associated with it.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getPartitionIdKeys">
<code class="descname">getPartitionIdKeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getPartitionIdKeys" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list containing unique (non-None) partition Ids (just the keys)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getPartitionIdList">
<code class="descname">getPartitionIdList</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getPartitionIdList" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of complete partition id objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getPattern">
<code class="descname">getPattern</code><span class="sig-paren">(</span><em>idx</em>, <em>sparseBinaryForm=False</em>, <em>cat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a training pattern either by index or category number.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>idx</strong> &#8211; Index of the training pattern</li>
<li><strong>sparseBinaryForm</strong> &#8211; If true, returns a list of the indices of the
non-zero bits in the training pattern</li>
<li><strong>cat</strong> &#8211; If not None, get the first pattern belonging to category cat. If
this is specified, idx must be None.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The training pattern with specified index</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.getPatternIndicesWithPartitionId">
<code class="descname">getPatternIndicesWithPartitionId</code><span class="sig-paren">(</span><em>partitionId</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.getPatternIndicesWithPartitionId" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a list of pattern indices corresponding to this partitionId.
Return an empty list if there are none.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.infer">
<code class="descname">infer</code><span class="sig-paren">(</span><em>inputPattern</em>, <em>computeScores=True</em>, <em>overCategories=True</em>, <em>partitionId=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the category that best matches the input pattern. Returns the
winning category index as well as a distribution over all categories.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputPattern</strong> &#8211; (list) A pattern to be classified</li>
<li><strong>computeScores</strong> &#8211; NO EFFECT</li>
<li><strong>overCategories</strong> &#8211; NO EFFECT</li>
<li><strong>partitionId</strong> &#8211; (int) If provided, all training vectors with partitionId
equal to that of the input pattern are ignored.
For example, this may be used to perform k-fold cross validation
without repopulating the classifier. First partition all the data into
k equal partitions numbered 0, 1, 2, ... and then call learn() for each
vector passing in its partitionId. Then, during inference, by passing
in the partition ID in the call to infer(), all other vectors with the
same partitionId are ignored simulating the effect of repopulating the
classifier while ommitting the training vectors in the same partition.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>4-tuple with these keys:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">winner</span></code>: The category with the greatest number of nearest neighbors</dt>
<dd>within the kth nearest neighbors. If the inferenceResult contains no
neighbors, the value of winner is None. This can happen, for example,
in cases of exact matching, if there are no stored vectors, or if
minSparsity is not met.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">inferenceResult</span></code>: A list of length numCategories, each entry contains</dt>
<dd>the number of neighbors within the top k neighbors that are in that
category.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">dist</span></code>: A list of length numPrototypes. Each entry is the distance</dt>
<dd>from the unknown to that prototype. All distances are between 0.0 and
1.0.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">categoryDist</span></code>: A list of length numCategories. Each entry is the</dt>
<dd>distance from the unknown to the nearest prototype of
that category. All distances are between 0 and 1.0.</dd>
</dl>
</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.learn">
<code class="descname">learn</code><span class="sig-paren">(</span><em>inputPattern</em>, <em>inputCategory</em>, <em>partitionId=None</em>, <em>isSparse=0</em>, <em>rowID=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.learn" title="Permalink to this definition">¶</a></dt>
<dd><p>Train the classifier to associate specified input pattern with a
particular category.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputPattern</strong> &#8211; (list) The pattern to be assigned a category. If
isSparse is 0, this should be a dense array (both ON and OFF bits
present). Otherwise, if isSparse &gt; 0, this should be a list of the
indices of the non-zero bits in sorted order</li>
<li><strong>inputCategory</strong> &#8211; (int) The category to be associated to the training
pattern</li>
<li><strong>partitionId</strong> &#8211; (int) partitionID allows you to associate an id with each
input vector. It can be used to associate input patterns stored in the
classifier with an external id. This can be useful for debugging or
visualizing. Another use case is to ignore vectors with a specific id
during inference (see description of infer() for details). There can be
at most one partitionId per stored pattern (i.e. if two patterns are
within distThreshold, only the first partitionId will be stored). This
is an optional parameter.</li>
<li><strong>isSparse</strong> &#8211; (int) If 0, the input pattern is a dense representation. If
isSparse &gt; 0, the input pattern is a list of non-zero indices and
isSparse is the length of the dense representation</li>
<li><strong>rowID</strong> &#8211; (int) UNKNOWN</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The number of patterns currently stored in the classifier</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.prototypeSetCategory">
<code class="descname">prototypeSetCategory</code><span class="sig-paren">(</span><em>idToCategorize</em>, <em>newCategory</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.prototypeSetCategory" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows ids to be assigned a category and subsequently enables users to use:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref py py-meth docutils literal"><span class="pre">removeCategory()</span></code></li>
<li><code class="xref py py-meth docutils literal"><span class="pre">closestTrainingPattern()</span></code></li>
<li><code class="xref py py-meth docutils literal"><span class="pre">closestOtherTrainingPattern()</span></code></li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.remapCategories">
<code class="descname">remapCategories</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.remapCategories" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the category indices.</p>
<p>Used by the Network Builder to keep the category indices in sync with the
ImageSensor categoryInfo when the user renames or removes categories.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mapping</strong> &#8211; List of new category indices. For example, mapping=[2,0,1]
would change all vectors of category 0 to be category 2, category 1 to
0, and category 2 to 1</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.removeCategory">
<code class="descname">removeCategory</code><span class="sig-paren">(</span><em>categoryToRemove</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.removeCategory" title="Permalink to this definition">¶</a></dt>
<dd><p>There are two caveats. First, this is a potentially slow operation. Second,
pattern indices will shift if patterns before them are removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>categoryToRemove</strong> &#8211; Category label to remove</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.removeIds">
<code class="descname">removeIds</code><span class="sig-paren">(</span><em>idsToRemove</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.removeIds" title="Permalink to this definition">¶</a></dt>
<dd><p>There are two caveats. First, this is a potentially slow operation. Second,
pattern indices will shift if patterns before them are removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>idsToRemove</strong> &#8211; A list of row indices to remove.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nupic.algorithms.knn_classifier.KNNClassifier.setCategoryOfVectors">
<code class="descname">setCategoryOfVectors</code><span class="sig-paren">(</span><em>vectorIndices</em>, <em>categoryIndices</em><span class="sig-paren">)</span><a class="headerlink" href="#nupic.algorithms.knn_classifier.KNNClassifier.setCategoryOfVectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the category associated with this vector(s).</p>
<p>Used by the Network Builder to move vectors between categories, to enable
categories, and to invalidate vectors by setting the category to -1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vectorIndices</strong> &#8211; Single index or list of indices</li>
<li><strong>categoryIndices</strong> &#8211; Single index or list of indices. Can also be a
single index when vectorIndices is a list, in which case the same
category will be used for all vectors</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/numenta-logo.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">NuPIC</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=numenta&repo=nupic&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../quick-start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/index.html">Guides</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API Docs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../opf/index.html">Online Prediction Framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">Network API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Algorithms</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="encoders.html">Encoders</a></li>
<li class="toctree-l3"><a class="reference internal" href="spatial-pooling.html">Spatial Pooling</a></li>
<li class="toctree-l3"><a class="reference internal" href="sequence-memory.html">Sequence Memory</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Classifiers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-nupic.algorithms.sdr_classifier">SDR Classifier</a></li>
<li class="toctree-l4"><a class="reference internal" href="#knn-classifier">KNN Classifier</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="anomaly-detection.html">Anomaly Detection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../data/index.html">Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../support/index.html">Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math.html">Math</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Numenta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../../_sources/api/algorithms/classifiers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/numenta/nupic" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>