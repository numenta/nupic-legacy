<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>OPF Description Template &#8212; NuPIC 1.0.3

 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="opf-description-template">
<h1>OPF Description Template<a class="headerlink" href="#opf-description-template" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-default"><div class="highlight"><pre><span></span># ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2013, Numenta, Inc.  Unless you have an agreement
# with Numenta, Inc., for a separate license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero Public License for more details.
#
# You should have received a copy of the GNU Affero Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

&quot;&quot;&quot;
Template file used by the OPF Experiment Generator to generate the actual
description.py file by replacing $XXXXXXXX tokens with desired values.

This description.py file was generated by:
$EXP_GENERATOR_PROGRAM_PATH
&quot;&quot;&quot;

from nupic.frameworks.opf.exp_description_api import ExperimentDescriptionAPI

from nupic.frameworks.opf.exp_description_helpers import (
  updateConfigFromSubConfig,
  applyValueGettersToContainer,
  DeferredDictLookup)

from nupic.frameworks.opf.htm_prediction_model_callbacks import *
from nupic.frameworks.opf.metrics import MetricSpec
from nupic.swarming.experiment_utils import (InferenceType, InferenceElement)
from nupic.support import aggregationDivide

from nupic.frameworks.opf.opf_task_driver import (
                                            IterationPhaseSpecLearnOnly,
                                            IterationPhaseSpecInferOnly,
                                            IterationPhaseSpecLearnAndInfer)



# ------------------------------------------------------------------------------
# Model Configuration Dictionary:
#
# Define the model parameters and adjust for any modifications if imported
# from a sub-experiment.
#
# These fields might be modified by a sub-experiment; this dict is passed between
# the sub-experiment and base experiment
#
#
# NOTE: Use of DEFERRED VALUE-GETTERs: dictionary fields and list elements
#   within the config dictionary may be assigned futures derived from the
#   ValueGetterBase class, such as DeferredDictLookup.
#   This facility is particularly handy for enabling substitution of values in
#   the config dictionary from other values in the config dictionary, which is
#   needed by permutation.py-based experiments. These values will be resolved
#   during the call to applyValueGettersToContainer(),
#   which we call after the base experiment&#39;s config dictionary is updated from
#   the sub-experiment. See ValueGetterBase and
#   DeferredDictLookup for more details about value-getters.
#
#   For each custom encoder parameter to be exposed to sub-experiment/permutation
#   overrides, define a variable in this section, using key names beginning with a
#   single underscore character to avoid collisions with pre-defined keys (e.g.,
#   _dsEncoderFieldName2_N).
#
#   Example:
#      config = dict(
#        _dsEncoderFieldName2_N = 70,
#        _dsEncoderFieldName2_W = 5,
#        dsEncoderSchema = [
#          base=dict(
#            fieldname=&#39;Name2&#39;, type=&#39;ScalarEncoder&#39;,
#            name=&#39;Name2&#39;, minval=0, maxval=270, clipInput=True,
#            n=DeferredDictLookup(&#39;_dsEncoderFieldName2_N&#39;),
#            w=DeferredDictLookup(&#39;_dsEncoderFieldName2_W&#39;)),
#        ],
#      )
#      updateConfigFromSubConfig(config)
#      applyValueGettersToContainer(config)
#

config = {

  # Type of model that the rest of these parameters apply to
  &#39;model&#39; : &quot;HTMPrediction&quot;,

  # The type of inference that this model will perform
  &#39;inferenceType&#39;: $INFERENCE_TYPE,

  # How much in advance we want to predict. Used only when swarming over
  #  aggregations
  &#39;predictAheadTime&#39;: $PREDICT_AHEAD_TIME,

  # The number of prediction steps to use. When swarming over aggregations, this
  #  is computed and filled in by the logic that follows this config
  #  declaration. It is computed based on the chosen aggreation and the
  #  above predictAheadTime.
  &#39;predictionSteps&#39;: &#39;FilledInBelow&#39;,


  ##############################################################################
  # Dataset Aggregation Parameters (for training and inference datasets)
  ##############################################################################

  # Time-based Dataset Aggregation rules;
  #
  # Usage details and additional options: see
  # nupic.data.aggregator.generateDataset()
  #
  # Aggregation presently begins at the start of the dataset. For every
  # aggregation period, the records within the period are coalesced into a
  # single record per rules specified via the aggregationInfo property.
  #
  # Value schema:
  #   {
  #     &#39;periodUnit1&#39;:value1, &#39;periodUnit2&#39;:value2, ...,
  #     &#39;fields&#39;:[(&#39;fieldNameA&#39;, aggFuncNameA), (&#39;fieldNameB&#39;, aggFuncNameB)]
  #   }
  #
  # Aggregation period units: combination of 0 or more unit/value properties:
  #   [years months] | [weeks days hours minutes seconds milliseconds microseconds]
  # NOTE: years and months are mutually-exclusive with the other units.
  # Example2: hours=1, minutes=30,
  #
  # Aggregation is disabled if the aggregationInfo key is omitted or all
  # expressed period unit values evaluate to 0
  #
  # Aggregation fields: list of field-name/aggregationFunctionName tuples;
  # e.g.: (&quot;consumpion&quot;, &quot;mean&quot;).
  #
  # Supported function names: &quot;first&quot;, &quot;last&quot;, &quot;mean&quot;, &quot;sum&quot; (per
  # nupic.data.aggregator.py)
  #
  # NOTE: Designated Sequence id, Reset, and Timestamp fields are included
  #      automatically if not specified in aggregation fields.
  #
  # Aggregation period can be permuted over, so is separated out
  # (generated from AGGREGATION_PERIOD)
  &#39;__aggregationPeriod&#39; : $AGGREGATION_PERIOD

  # (value generated from AGGREGATION_INFO)
  &#39;aggregationInfo&#39; : $AGGREGATION_INFO,


  ##############################################################################
  # Sensor Region Parameters
  ##############################################################################

  # Sensor diagnostic output verbosity control;
  # if &gt; 0: sensor region will print out on screen what it&#39;s sensing at each step
  # 0: silent; &gt;=1: some info; &gt;=2: more info; &gt;=3: even more info
  # (see compute() in py/regions/RecordSensor.py)
  #
  &#39;sensorVerbosity&#39; : 0,

  # A dictionary specifying the period for automatically-generated resets from
  # a RecordSensor;
  #
  # None = disable automatically-generated resets (also disabled if all of the
  # specified values evaluate to 0).
  # Valid keys is the desired combination of the following:
  #   days, hours, minutes, seconds, milliseconds, microseconds, weeks
  #
  # Example for 1.5 days: sensorAutoReset = dict(days=1,hours=12),
  #
  # (value generated from SENSOR_AUTO_RESET)
  &#39;sensorAutoReset&#39; : $SENSOR_AUTO_RESET,


  # Dataset Encoder consists of field encoders that convert dataset record fields
  # to the internal representations suitable for input to the Sensor Region.
  #
  # Each field encoder dict must have the following keys per
  # nupic.encoders.MultiEncoder (multi.py):
  #  1) data fieldname          (&#39;fieldname&#39;)
  #  2) an encoder type         (&#39;type&#39;)
  #  3) and the encoder params  (all other keys)
  #
  # See specific encoder modules (e.g., sdrcateogry.py, scalar.py,
  # date.py, etc.) for encoder type values and descriptions of their specific params.
  #
  # Schema that describes how to build the encoder configuration.
  #
  #   dsEncoderSchema: [encoderSpec1, encoderSpec2, ...]
  #   encoderSpec: dictionary of parameters describing the field encoder
  #
  # In this dsEncoderSchema example, the field name &quot;Name1&quot; is a timestamp,
  # &quot;Name2&quot; is a scalar quantity, and &quot;Name3&quot; is a category
  #

  # Encoder specs;
  # Example:
  #          __field_name_encoder = dict(
  #            type = SDRCategoryEncoder&#39;,
  #            fieldname = name&#39;,
  #            name = &#39;name&#39;,
  #            n = 1000,
  #            w = DeferredDictLookup(&#39;spNumActivePerInhArea&#39;),
  #          )
  # Generated from ENCODER_SPECS
  #
  $ENCODER_SPECS,


  # Example:
  #     dsEncoderSchema = [
  #       DeferredDictLookup(&#39;__field_name_encoder&#39;),
  #     ],
  #
  # (value generated from DS_ENCODER_SCHEMA)
  #
  &#39;dsEncoderSchema&#39; : $DS_ENCODER_SCHEMA,



  ##############################################################################
  # General CLA Region Parameters
  ##############################################################################

  # Number of cell columns in the cortical region (same number for SP and TM)
  # (see also tpNCellsPerCol)
  # Replaces: spCoincCount
  &#39;claRegionNColumns&#39; : 2048,


  ##############################################################################
  # Spatial Pooler (SP) Parameters (SP is always enabled in OPF)
  ##############################################################################

  # SP diagnostic output verbosity control;
  # 0: silent; &gt;=1: some info; &gt;=2: more info;
  #
  &#39;spVerbosity&#39; : 0,

  # Print/logs stats every N iterations; 0 = disable stats
  &#39;spPrintStatsPeriodIter&#39; : 0,

  # SP inhibition control (absolute value);
  # Maximum number of active columns in the SP region&#39;s output (when there are more,
  # the weaker ones are suppressed)
  #
  &#39;spNumActivePerInhArea&#39; : 40,

  # potentialPct
  # What percent of the columns&#39;s receptive field is available
  # for potential synapses. At initialization time, we will
  # choose potentialPct * (2*potentialRadius+1)^2
  &#39;spCoincInputPoolPct&#39; : $SP_POOL_PCT,

  # The default connected threshold. Any synapse whose
  # permanence value is above the connected threshold is
  # a &quot;connected synapse&quot;, meaning it can contribute to the
  # cell&#39;s firing. Typical value is 0.10. Cells whose activity
  # level before inhibition falls below minDutyCycleBeforeInh
  # will have their own internal synPermConnectedCell
  # threshold set below this default value.
  # (This concept applies to both SP and TM and so &#39;cells&#39;
  # is correct here as opposed to &#39;columns&#39;)
  &#39;spSynPermConnected&#39; : $SP_PERM_CONNECTED,




  ##############################################################################
  # Temporal Memory (TM) Parameters
  ##############################################################################

  # TM diagnostic output verbosity control;
  # 0: silent; [1..6]: increasing levels of verbosity
  # (see verbosity in nupic/trunk/py/nupic/research/BacktrackingTM.py and BacktrackingTMCPP.py)
  #
  &#39;tpVerbosity&#39; : 0,

  # Print stats every N iterations during training; 0 = disable stats
  # TODO Why aren&#39;t experiments configuring stats for the inference phase? It seems
  #   like SP stats are dumped by SP Pooler directly regardless of whether it&#39;s
  #   in training or inference phase.  (waiting for email from Ron)
  # TODO: In LPF, these were accumulated/printed via iter/final callbacks installed
  #       by LPF; solve in OPF.
  &#39;tpTrainPrintStatsPeriodIter&#39; : 0,

  # Controls whether TM is enabled or disabled;
  # TM is necessary for making temporal predictions, such as predicting the next
  # inputs.  Without TP, the model is only capable of reconstructing missing sensor
  # inputs (via SP).
  #
  &#39;tmEnable&#39; : True,

  # The number of cells (i.e., states), allocated per column
  #
  &#39;tpNCellsPerCol&#39; : 32,

  # Initial Permanence
  # TODO need better explanation
  #
  &#39;tpInitialPerm&#39; : 0.21,

  # Permanence Increment
  #
  &#39;tpPermanenceInc&#39; : 0.1,

  # Permanence Decrement
  # If set to None, will automatically default to tpPermanenceInc value
  #
  &#39;tpPermanenceDec&#39; : None,

  # Temporal Pooler implementation selector (see _getTPClass in CLARegion.py)
  #
  &#39;tpImplementation&#39; : &#39;cpp&#39;,

  # Maximum number of segments per cell
  #  &gt; 0 for fixed-size CLA
  # -1 for non-fixed-size CLA
  #
  # TODO for Ron: once the appropriate value is placed in TM constructor, see if
  #  we should eliminate this parameter from description.py
  #
  &#39;tpMaxSegmentsPerCell&#39; : 128,

  # Segment activation threshold.
  # A segment is active if it has &gt;= tpSegmentActivationThreshold connected
  # synapses that are active due to infActiveState
  # None=use default
  # Replaces: tpActivationThreshold
  &#39;tpSegmentActivationThreshold&#39; : None,

  # Minimum number of active synapses for a segment to be considered during
  # search for the best-matching segments.
  # None=use default
  # Replaces: tpMinThreshold
  &#39;tpMinSegmentMatchSynapseThreshold&#39; : None,

  # Maximum number of synapses per segment
  #  &gt; 0 for fixed-size CLA
  # -1 for non-fixed-size CLA
  #
  # TODO for Ron: once the appropriate value is placed in TM constructor, see if
  #  we should eliminate this parameter from description.py
  #
  &#39;tpMaxSynapsesPerSegment&#39; : 32,

  # New Synapse formation count
  # NOTE: If None, use spNumActivePerInhArea
  #
  # TODO need better explanation
  #
  &#39;tpNewSynapseCount&#39; : 20,

  # &quot;Pay Attention Mode&quot; length. This tells the TM how many new elements
  # to append to the end of a learned sequence at a time. Smaller values are
  # better for datasets with short sequences, higher values are better for
  # datasets with long sequences.
  &#39;tpPamLength&#39;: 1,


  ##############################################################################
  # SDRClassifier parameters
  ##############################################################################
  &#39;clRegionName&#39; : &#39;SDRClassifierRegion&#39;,


  # Classifier diagnostic output verbosity control;
  # 0: silent; [1..6]: increasing levels of verbosity
  #
  &#39;verbosity&#39; : 0,

  # Comma separated list of steps ahead to learn in the classifier.
  &#39;clSteps&#39;: $PREDICTION_STEPS,

  # This controls how fast the classifier learns/forgets. Higher values
  # make it adapt faster and forget older patterns faster.
  &#39;clAlpha&#39;: None,

  # This allows the user to specify custom classifier params
  &#39;clAdvancedParams&#39; : {},
}

# end of config dictionary


# Adjust base config dictionary for any modifications if imported from a
# sub-experiment
updateConfigFromSubConfig(config)

# Compute predictionSteps based on the predictAheadTime and the aggregation
# period, which may be permuted over.
if config[&#39;predictAheadTime&#39;] is not None:
  predictionSteps =  int(round(aggregationDivide(
        config[&#39;predictAheadTime&#39;], config[&#39;__aggregationPeriod&#39;])))
  assert (predictionSteps &gt;= 1)
  config[&#39;clSteps&#39;] = &#39;%s&#39; % (predictionSteps)


# Adjust config by applying ValueGetterBase-derived
# futures. NOTE: this MUST be called after updateConfigFromSubConfig() in order
# to support value-getter-based substitutions from the sub-experiment (if any)
applyValueGettersToContainer(config)
</pre></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/numenta-logo.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../../index.html">NuPIC</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=numenta&repo=nupic&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quick-start/index.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guides/index.html">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../index.html">API Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Numenta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../../_sources/api/opf/description-template.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/numenta/nupic" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>