<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>OPF Guide &#8212; NuPIC 0.8.0.dev0
 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.8.0.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Network API Guide" href="network.html" />
    <link rel="prev" title="Guides" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="opf-guide">
<span id="opf-guide"></span><h1>OPF Guide<a class="headerlink" href="#opf-guide" title="Permalink to this headline">¶</a></h1>
<p>Online Prediction Framework (OPF) is a framework for working with and deriving predictions from online learning algorithms, including HTM. OPF is designed to work in conjunction with a larger architecture, as well as in a standalone mode (i.e. directly from the command line). It is also designed such that new model algorithms and functionalities can be added with minimal code changes.</p>
<div class="section" id="examples">
<span id="examples"></span><h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Here are some examples of applications using the OPF interface:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/numenta/nupic/tree/master/examples/opf/clients/cpu"><code class="docutils literal"><span class="pre">examples/opf/clients/cpu</span></code></a></li>
<li><a class="reference external" href="https://github.com/numenta/nupic/tree/master/examples/opf/clients/hotgym/prediction/one_gym"><code class="docutils literal"><span class="pre">examples/opf/clients/hotgym/prediction/one_gym</span></code></a></li>
<li><a class="reference external" href="https://github.com/numenta/nupic/tree/master/examples/opf/clients/hotgym/anomaly"><code class="docutils literal"><span class="pre">examples/opf/clients/hotgym/anomaly</span></code></a></li>
<li><a class="reference external" href="https://github.com/numenta/nupic/tree/master/examples/opf/clients/hotgym/anomaly/one_gym"><code class="docutils literal"><span class="pre">examples/opf/clients/hotgym/anomaly/one_gym</span></code></a></li>
</ul>
</div>
<div class="section" id="opf-in-a-nutshell">
<span id="opf-in-a-nutshell"></span><h2>OPF in a nutshell<a class="headerlink" href="#opf-in-a-nutshell" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="../api/algorithms/encoders.html"><strong>Encoders</strong></a> turn raw values into sparse distributed representations (SDRs).  A good encoder will capture the semantics of the data type in the SDR using overlapping bits for semantically similar values.</p>
<p><a class="reference external" href="../api/opf/models.html"><strong>Models</strong></a> take sequences of SDRs and make predictions.  The CLA is implemented as an OPF model.</p>
<p><a class="reference external" href="../api/opf/metrics.html"><strong>Metrics</strong></a> take input values and predictions and output scalar representations of the quality of the predictions.  Different metrics are suitable for different problems.</p>
<p><strong>Clients</strong> take input data and feed it through encoders, models, and metrics and store or report the resulting predictions or metric results.</p>
</div>
<div class="section" id="what-does-the-opf-do">
<span id="what-does-the-opf-do"></span><h2>What does the OPF do?<a class="headerlink" href="#what-does-the-opf-do" title="Permalink to this headline">¶</a></h2>
<p>The OPF has three main responsibilities:</p>
<ol class="simple">
<li>Provide an interface/implementations for models</li>
<li>Compute metrics on the output of models</li>
<li>Provide an interface to write model output to a permanent store (csv file or some form
of database)</li>
</ol>
<p>Each of these 3 components is in a separate set of modules. Metrics and writing output are optional when running models.</p>
<p><img alt="Data flow in the OPF" src="guides/../../_static/opf-figure1.png" /></p>
<blockquote>
<div>Figure 1: Data flow in the OPF</div></blockquote>
</div>
<div class="section" id="what-doesnt-the-opf-do">
<span id="what-doesnt-the-opf-do"></span><h2>What doesn’t the OPF do?<a class="headerlink" href="#what-doesnt-the-opf-do" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>The OPF does not create models. It is up to the client code to figure out how many models to run, and to instantiate the correct types of models</li>
<li>The OPF does not run models automatically. All the models in the OPF operate under a “push” model. The client is responsible for getting records from some data source, feeding records into the model, and handling the output of models.</li>
</ul>
</div>
<div class="section" id="models">
<span id="models"></span><h2>Models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-model-interface">
<span id="the-model-interface"></span><h3>The Model Interface<a class="headerlink" href="#the-model-interface" title="Permalink to this headline">¶</a></h3>
<p>The OPF defines the abstract &#8220;Model&#8221; interface for the implementation of any online learning model. Implementers typically subclass the <a class="reference external" href="../api/opf/models.html#model">base class</a> provided. All models must implement the following methods:</p>
<ul>
<li><p class="first"><strong>__init__(modelDescription, inferenceType)</strong></p>
<p>Constructor for the model. Must take a modelDescription dictionary, which contains all the parameters necessary to instantiate the model, and an InferenceType value (see below). <em>A model’s __init__() method should always call the __init__() method of the superclass.</em></p>
</li>
<li><p class="first"><strong>run(inputRecord)</strong></p>
<p>The main function for the model that does all the computation required for a new input record. Because the OPF only deals with online streaming models, each record is fed to the model one at a time
Returns: A populated ModelResult object (see below)</p>
</li>
<li><p class="first"><strong>getFieldInfo()</strong></p>
<p>Returns a list of metadata about each of the translated fields (see below about translation). Each entry in the list is a FieldMetaInfo object, which contains information about the field, such as name and data type
Returns: A list of FieldMetaInfo objects</p>
</li>
<li><p class="first"><strong>finishLearning()</strong></p>
<p>This is a signal from the client code that the model may be placed in a permanent &#8220;finished learning&#8221; mode where it will not be able to learn from subsequent input records. This allows the model to perform optimizations and clean up any learning-related state Returns: Nothing</p>
</li>
<li><p class="first"><strong>resetSequenceStates()</strong></p>
<p>Signals the model that a logical sequence has finished. The model should not treat the subsequent input record as subsequent to the previous record.
Returns: Nothing</p>
</li>
<li><p class="first"><strong>mapInputRecord()</strong> - not used</p>
</li>
<li><p class="first"><strong>getRuntimeStats()</strong> – [can be a no-op]</p>
<p>Get runtime statistics specific to this model. Examples include “number of records seen” or “average cell overlap”</p>
<p>Returns: A dictionary where the keys are the statistic names, and the values are the
statistic values</p>
</li>
<li><p class="first"><strong>_getLogger()</strong> – [used by parent class]</p>
<p>Returns: The logging object for this class. This is used so that that the operations in the superclass use the same logger object.</p>
</li>
</ul>
<p>It also provides the following functionality, common to all models:</p>
<ul>
<li><p class="first"><strong>enableLearning()/disableLearning()</strong></p>
<p>Set’s the learning flag for the model. This can be queried internally and externally using the isLearningEnabled() method</p>
</li>
<li><p class="first"><strong>enableInference(inferenceArgs=None)/disableInference()</strong></p>
<p>Enables/Disables inference output for this model. Enabling inference takes an optional argument inferenceArgs, which is a dictionary with extra parameters that affect how inference is performed. For instance, an anomaly detection model may have a boolean parameter “doPrediction”, which toggles whether or not a prediction is computed in addition to the anomaly score.</p>
<p>The inference state of a model can be queried internally and externally using the isInferenceEnabled() method. The inference arguments can be queried using the getInferenceArgs() method.</p>
</li>
<li><p class="first"><strong>save(saveModelDir)</strong></p>
<p>Save the model state via pickle and saves the resulting object in the saveModelDir directory.</p>
</li>
<li><p class="first"><strong>_serializeExtraData(extaDataDir)/_deSerializeExtraData(extraDataDir)</strong></p>
<p>If there is state that cannot be pickled and needs to be saved separately, this can be done by overriding these methods (implemented as no-ops by default).</p>
</li>
</ul>
</div>
<div class="section" id="model-input">
<span id="model-input"></span><h3>Model Input<a class="headerlink" href="#model-input" title="Permalink to this headline">¶</a></h3>
<p><img alt="Records are input to models in the form of dictionary-like objects, where the keys are field names and the values are the raw field values." src="guides/../../_static/opf-figure2.png" /></p>
<blockquote>
<div>Figure 2: Records are input to models in the form of dictionary-like objects, where the keys are field names and the values are the raw field values.</div></blockquote>
<div class="section" id="translation">
<span id="translation"></span><h4>Translation<a class="headerlink" href="#translation" title="Permalink to this headline">¶</a></h4>
<p>Certain field types need to be converted into primitive input types. For example, datetime types are converted to 2 integer values, timeOfDay and dayOfWeek. In the OPF, this process is called <strong>translation</strong>. Generally, all models will have a translation step. Conceptually, translation produces two parallel lists (for performance reasons): A list of field metadata, and a list of translated field values. In practice, the first list is constant, so it can be pre-computed and stored in the model. This is the return value of <strong>getFieldInfo()</strong>.</p>
</div>
<div class="section" id="encoding">
<span id="encoding"></span><h4>Encoding<a class="headerlink" href="#encoding" title="Permalink to this headline">¶</a></h4>
<p>Additionally, for some model types (such as the CLA model), the translated inputs are quantized (put into buckets) and converted into binary vector representation. This process is called <strong><em>encoding</em></strong> and is handled by <a class="reference external" href="Encoders">encoders</a> (specific encoders for different data types exist). Most models may not need to encode the input (or, more likely, they will just need to quantize the input).</p>
</div>
</div>
<div class="section" id="model-output-the-modelresult-object">
<span id="model-output-the-modelresult-object"></span><h3>Model Output: The ModelResult Object<a class="headerlink" href="#model-output-the-modelresult-object" title="Permalink to this headline">¶</a></h3>
<p>The ModelResult object is the main data container in the OPF. When a record is fed to a model, it instantiates a new ModelResult instance, which contains model input and inferences, and is shuttled around to the various OPF modules. Below is a description of each of the ModelResult attributes. They default to <strong>None</strong> when the ModelResult is instantiated, and must be populated by the Model object.</p>
<ul class="simple">
<li><strong>rawInput</strong>: This is the exact record that is fed into the model. It is a dictionary-like object where the keys are the input field names, and the values are input values of the fields. All the input values maintain their original types.</li>
<li><strong>sensorInput</strong>: The translated input record, as well as auxiliary information about the input (See below)</li>
<li><strong>inferences</strong>: A dictionary that contains the output of a model (i.e. its inference). The keys are InferenceElement values (described below), and the values are the corresponding inference values</li>
<li><strong>metrics</strong>: A dictionary where the keys are the unique metric labels, and the values are the metric values (a single float). This is the only element that is not populated by the model object, but by the surrounding code.</li>
</ul>
<div class="section" id="raw-input-vs-sensor-input">
<span id="raw-input-vs-sensor-input"></span><h4>Raw Input vs. Sensor Input<a class="headerlink" href="#raw-input-vs-sensor-input" title="Permalink to this headline">¶</a></h4>
<p>As explained above, fields from the raw input are translated into primitive input types. There also may be additional information about the input record that is needed by the OPF framework. The SensorInput object is a container that stores translated input record, as well
as auxiliary information about the input. More attributes may be added to the SensorInput object as new features require them. Note: not every model needs to populate every field in SensorInput, and the exact requirements depend on which inferences and metrics are being computed.</p>
<ul class="simple">
<li><strong>sequenceReset</strong>: Control field for temporal patterns. This field has a value of 1 if an explicit temporal reset was specified for this record, 0 otherwise. Resets are currently not being used.</li>
<li><strong>dataRow</strong>: The translated version of the input row.</li>
<li><strong>dataEncodings</strong>: The encoded version of the input, used by some metrics. This is a list of
binary numpy arrays, one for each field in dataRow.</li>
<li><strong>category</strong>: In classification problems, this is the class label for the input record.</li>
</ul>
</div>
</div>
<div class="section" id="inference-elements">
<span id="inference-elements"></span><h3>Inference Elements<a class="headerlink" href="#inference-elements" title="Permalink to this headline">¶</a></h3>
<p>The concept of InferenceElements is a key part of the OPF. A model&#8217;s inference may have multiple parts to it. For example, a model may output both a prediction and an anomaly score. Models output their set of inferences as a dictionary that is keyed by the enumerated type InferenceElement. Each entry in an inference dictionary is considered a separate inference element, and is handled independently by the OPF.</p>
<p>Data structures related to inference elements are located in <a class="reference external" href="https://github.com/numenta/nupic/blob/master/nupic/frameworks/opf/opf_utils.py"><strong>opf_utils.py</strong></a>.</p>
<div class="section" id="inference-data-types">
<span id="inference-data-types"></span><h4>Inference Data Types<a class="headerlink" href="#inference-data-types" title="Permalink to this headline">¶</a></h4>
<p>For reasons unknown and poorly explained, the OPF handles different data types for inferences differently. This helps with the automation of handling new inference types, but can be confusing.</p>
</div>
<div class="section" id="mapping-inferences-to-input-values">
<span id="mapping-inferences-to-input-values"></span><h4>Mapping Inferences to Input Values<a class="headerlink" href="#mapping-inferences-to-input-values" title="Permalink to this headline">¶</a></h4>
<p>In order to compute metrics and write output, the OPF needs to know which input values (i.e. attributes of SensorInput) correspond to each inference element. This mapping between inputs and outputs are defined in InferenceElement.__inferenceInputMap. By specifying this mapping here, the same logic can be used both for writing to output and computing metrics</p>
<p>￼￼Below is an example.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InferenceElement</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>

<span class="o">...</span>

    <span class="n">_inferenceInputMap</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;prediction&quot;</span><span class="p">:</span> <span class="s2">&quot;dataRow&quot;</span><span class="p">,</span>
        <span class="s2">&quot;encodings&quot;</span><span class="p">:</span> <span class="s2">&quot;dataEncodings&quot;</span><span class="p">,</span>
        <span class="s2">&quot;classification&quot;</span><span class="p">:</span> <span class="s2">&quot;category&quot;</span><span class="p">,</span>
        <span class="s2">&quot;multiStepPredictions&quot;</span><span class="p">:</span> <span class="s2">&quot;dataRow&quot;</span>
    <span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div>Snippet 1: Mapping inferences to input</div></blockquote>
<p>In this example, we can see that the “<em>prediction</em>” inference element is associated with SensorInput.dataRow, and the “<em>classification</em>” inference element is associated with SensorInput.category.</p>
<p>This association is used to compute metrics and to determine which parts of the input to write to output. For example, to compute error, the value of “<em>prediction</em>” will be compared to the value of SensorInput.dataRow, and the value of “<em>classification</em>” will be compared to value of SensorInput.category</p>
<p><img alt="Inference elements" src="guides/../../_static/opf-figure3.png" /></p>
<blockquote>
<div>Figure 3: Inference Elements</div></blockquote>
<p>When a new inference element is added, an entry needs to be added in this map to connect it with input.</p>
<p>For example, if we add a new inferenceElement InferenceElement.foo, which corresponds to dataRow (i.e. the groundTruth value for foo will be contained in dataRow), you will need to add an entry:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">InferenceElement</span><span class="o">.</span><span class="n">foo</span> <span class="p">:</span> <span class="s2">&quot;dataRow&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="shifting-inferences">
<span id="shifting-inferences"></span><h4>Shifting Inferences<a class="headerlink" href="#shifting-inferences" title="Permalink to this headline">¶</a></h4>
<p>Because OPF Models make predictions about the future, the OPF needs to line up inferences with their respective ground truth values so that it can compute metrics and write results appropriately. For example, InferenceElement.prediction is a prediction about the next record. In order to compute error metrics, this inference needs to be shifted one record forward in time to be compared with its corresponding ground-truth record.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">getTemporalDelay</span><span class="p">(</span><span class="n">inferenceElement</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

  <span class="k">if</span> <span class="n">inferenceElement</span> <span class="ow">in</span> <span class="p">(</span><span class="n">InferenceElement</span><span class="o">.</span><span class="n">prediction</span><span class="p">,</span>
                          <span class="n">InferenceElement</span><span class="o">.</span><span class="n">encodings</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>

  <span class="k">if</span> <span class="n">inferenceElement</span> <span class="ow">in</span> <span class="p">(</span><span class="n">InferenceElement</span><span class="o">.</span><span class="n">anomalyScore</span><span class="p">,</span>
                          <span class="n">InferenceElement</span><span class="o">.</span><span class="n">classification</span><span class="p">,</span>
                          <span class="n">InferenceElement</span><span class="o">.</span><span class="n">classConfidences</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span>

  <span class="k">if</span> <span class="n">inferenceElement</span> <span class="ow">in</span> <span class="p">(</span><span class="n">InferenceElement</span><span class="o">.</span><span class="n">multiStepPredictions</span><span class="p">,</span>
                          <span class="n">InferenceElement</span><span class="o">.</span><span class="n">multiStepBestPredictions</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

  <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<blockquote>
<div>Snippet 2: The getTemporalDelay() method defines how inferences are shifted</div></blockquote>
<p>The <strong>InferenceElement</strong> class defines the <strong>getTemporalDelay()</strong> method, which specifies how much a given inference element needs to be shifted in time. For dictionaries, an optional key argument is supplied, each entry in the dictionary can be shifted by a different amount.</p>
<p>This shifting applies to both csv output and metrics calculation. Each inference element in a ModelResult is shifted independently of the other inference elements, so you can have inferences about multiple points in the future all contained in a single ModelResult.</p>
<p>Below is an example of how this shifting occurs to compute errors:</p>
<p><img alt="Shifting" src="guides/../../_static/opf-figure4.png" /></p>
<blockquote>
<div>Figure 4: Shifting</div></blockquote>
</div>
</div>
</div>
<div class="section" id="metrics">
<span id="metrics"></span><h2>Metrics<a class="headerlink" href="#metrics" title="Permalink to this headline">¶</a></h2>
<p>The 2nd responsibility of the OPF is to compute metrics on a model&#8217;s output. Typically, this is some form of error metric, but in truth it can be any kind of score computed from the information in the input record and the output inferences. Metric calculations are handled by the PredictionMetricManager, which is instantiated with a series of MetricSpec objects (see below). The MetricsManager also handles shifting all the inferences appropriately before they are fed into their respective metrics modules</p>
<div class="section" id="metric-specs">
<span id="metric-specs"></span><h3>Metric Specs<a class="headerlink" href="#metric-specs" title="Permalink to this headline">¶</a></h3>
<p>A metric calculation is specified by creating a MetricSpec object. This is a container object that contains 4 fields:</p>
<ul class="simple">
<li>inferenceElement</li>
<li>metric</li>
<li>field (optional)</li>
<li>params (optional)</li>
</ul>
<p>Here is an example MetricSpec:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">MetricSpec</span><span class="p">(</span>  <span class="n">inferenceElement</span><span class="o">=</span><span class="n">InferenceElement</span><span class="o">.</span><span class="n">multiStepBest</span><span class="p">,</span>
             <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;aae&quot;</span><span class="p">,</span>
             <span class="n">field</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span>
             <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;window&quot;</span> <span class="p">:</span> <span class="mi">200</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</div>
<p>This means that we are calculating the average absolute error (&#8220;aae&#8221;) on the multiStepBest inference element, for the entry that corresponds to the field &#8220;foo&#8221;, and with an optional parameter &#8220;window&#8221; set to 200.</p>
</div>
<div class="section" id="metriclabels">
<span id="metriclabels"></span><h3>MetricLabels<a class="headerlink" href="#metriclabels" title="Permalink to this headline">¶</a></h3>
<p>Metrics need to be able to be uniquely identified, so that the experiment can indicate which metric should be optimized and which should be written to output. To this end, metric specs can return a &#8220;metric label&#8221;, which is a &#8220;human readable&#8221; (barely) string that contains all the information to uniquely identify the metric. The metric label for the above metric spec would be:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="s2">&quot;multiStepBest:aae:window=200:field=foo&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="metrics-calculation-modules-metrics-py">
<span id="metrics-calculation-modules-metrics-py"></span><h3>Metrics Calculation Modules (metrics.py)<a class="headerlink" href="#metrics-calculation-modules-metrics-py" title="Permalink to this headline">¶</a></h3>
<p>The modules that actually calculate metrics are located in metrics.py. They all inherit the abstact base class Metric, and they must define the following methods.</p>
<ul class="simple">
<li><strong>addInstance( prediction, groundTruth, record)</strong>: This is the method where a new inference-groundTruth pair is passed to the metric. Additionally, the raw input record is
also passed to the metric calculator. The module is responsible for calculating the metric
and storing the relevant information here.</li>
<li><strong>getMetric()</strong><ul>
<li>Returns a dictionary with the metric value and any auxillary information. The
metric&#8217;s value is stored under the key &#8216;value&#8217; (confusing, right?)<ul>
<li>Ex. { &#8216;value&#8217;: 10.3, &#8216;numIterations&#8217;: 1003}</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="output">
<span id="output"></span><h2>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<p>Types: Different inference value types are handled differently. The OPF distinguishes between 3 types: lists, dicts, and other. Lists are assumed to be associated with the model&#8217;s getFieldInfo() output. An individual element is always output as a string, no matter it&#8217;s actual type. Dicts are the most general, and separate columns are created for each key. Each entry in a dictionary is output as a string, no matter its type.</p>
<div class="section" id="outputting-inferences">
<span id="outputting-inferences"></span><h3>Outputting Inferences<a class="headerlink" href="#outputting-inferences" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>type inference on inference values</li>
<li>writing to a file (re: column creation)</li>
<li>writing to a db</li>
<li>Types</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/numenta-logo.png" alt="Logo"/>
            </a></p>
<h1 class="logo"><a href="../index.html">NuPIC</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=numenta&repo=nupic&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quick-start/index.html">Quick Start</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Guides</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">OPF Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#opf-in-a-nutshell">OPF in a nutshell</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-does-the-opf-do">What does the OPF do?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#what-doesnt-the-opf-do">What doesn’t the OPF do?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#models">Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-model-interface">The Model Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-input">Model Input</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model-output-the-modelresult-object">Model Output: The ModelResult Object</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inference-elements">Inference Elements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#metrics">Metrics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#metric-specs">Metric Specs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metriclabels">MetricLabels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metrics-calculation-modules-metrics-py">Metrics Calculation Modules (metrics.py)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#output">Output</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#outputting-inferences">Outputting Inferences</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="network.html">Network API Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="swarming/index.html">Swarming</a></li>
<li class="toctree-l2"><a class="reference internal" href="anomaly-detection.html">Anomaly Detection</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API Docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing/index.html">Contributing</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Numenta.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/guides/opf.md.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/numenta/nupic" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
  </body>
</html>