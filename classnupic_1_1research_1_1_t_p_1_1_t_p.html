<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>NuPIC: TP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="numenta-logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">NuPIC
   &#160;<span id="projectnumber">0.5.7.dev0</span>
   </div>
   <div id="projectbrief">Numenta Platform for Intelligent Computing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>nupic</b></li><li class="navelem"><b>research</b></li><li class="navelem"><b>TP</b></li><li class="navelem"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html">TP</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classnupic_1_1research_1_1_t_p_1_1_t_p-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TP Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algorithm documentation.  
 <a href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for TP:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classnupic_1_1research_1_1_t_p_1_1_t_p.png" usemap="#TP_map" alt=""/>
  <map id="TP_map" name="TP_map">
<area href="classnupic_1_1research_1_1_t_p10_x2_1_1_t_p10_x2.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo..." alt="TP10X2" shape="rect" coords="0,56,57,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p_1_1_segment_update.html">SegmentUpdate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to carry instructions for updating a segment.  <a href="classnupic_1_1research_1_1_t_p_1_1_t_p_1_1_segment_update.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac775ee34451fdfa742b318538164070e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ac775ee34451fdfa742b318538164070e">__init__</a></td></tr>
<tr class="memdesc:ac775ee34451fdfa742b318538164070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>.  <a href="#ac775ee34451fdfa742b318538164070e">More...</a><br/></td></tr>
<tr class="separator:ac775ee34451fdfa742b318538164070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7fcd430006ce19ec90516d90565e1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e7fcd430006ce19ec90516d90565e1c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9e7fcd430006ce19ec90516d90565e1c">saveToFile</a></td></tr>
<tr class="memdesc:a9e7fcd430006ce19ec90516d90565e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implemented in <a class="el" href="classnupic_1_1research_1_1_t_p10_x2_1_1_t_p10_x2.html#a9e7fcd430006ce19ec90516d90565e1c" title="Save Cells4 state to this file. ">TP10X2.TP10X2.saveToFile</a>. <br/></td></tr>
<tr class="separator:a9e7fcd430006ce19ec90516d90565e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14df89443d1ae6416e164e6ceba560a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14df89443d1ae6416e164e6ceba560a5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a14df89443d1ae6416e164e6ceba560a5">loadFromFile</a></td></tr>
<tr class="memdesc:a14df89443d1ae6416e164e6ceba560a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implemented in <a class="el" href="classnupic_1_1research_1_1_t_p10_x2_1_1_t_p10_x2.html#a14df89443d1ae6416e164e6ceba560a5" title="Load Cells4 state from this file. ">TP10X2.TP10X2.loadFromFile</a>. <br/></td></tr>
<tr class="separator:a14df89443d1ae6416e164e6ceba560a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13463c21005956b949860ac0eda9b3e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a13463c21005956b949860ac0eda9b3e3">reset</a></td></tr>
<tr class="memdesc:a13463c21005956b949860ac0eda9b3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the state of all cells.  <a href="#a13463c21005956b949860ac0eda9b3e3">More...</a><br/></td></tr>
<tr class="separator:a13463c21005956b949860ac0eda9b3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c0d71cd4c827f01109b3801194b5a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a3c5c0d71cd4c827f01109b3801194b5a">resetStats</a></td></tr>
<tr class="memdesc:a3c5c0d71cd4c827f01109b3801194b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the learning and inference stats.  <a href="#a3c5c0d71cd4c827f01109b3801194b5a">More...</a><br/></td></tr>
<tr class="separator:a3c5c0d71cd4c827f01109b3801194b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac6450a1abccd3bc55ef2691a9a60cc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a4ac6450a1abccd3bc55ef2691a9a60cc">getStats</a></td></tr>
<tr class="memdesc:a4ac6450a1abccd3bc55ef2691a9a60cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current learning and inference stats.  <a href="#a4ac6450a1abccd3bc55ef2691a9a60cc">More...</a><br/></td></tr>
<tr class="separator:a4ac6450a1abccd3bc55ef2691a9a60cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a350a9416a820ed41d18eb248c2b76b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a8a350a9416a820ed41d18eb248c2b76b">printState</a></td></tr>
<tr class="memdesc:a8a350a9416a820ed41d18eb248c2b76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an integer array that is the same shape as activeState.  <a href="#a8a350a9416a820ed41d18eb248c2b76b">More...</a><br/></td></tr>
<tr class="separator:a8a350a9416a820ed41d18eb248c2b76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addce5cc48d11e8822767781522d64621"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#addce5cc48d11e8822767781522d64621">printConfidence</a></td></tr>
<tr class="memdesc:addce5cc48d11e8822767781522d64621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a floating point array that is the same shape as activeState.  <a href="#addce5cc48d11e8822767781522d64621">More...</a><br/></td></tr>
<tr class="separator:addce5cc48d11e8822767781522d64621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441eb8544c0ed9fe294a5b424390bfa1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a441eb8544c0ed9fe294a5b424390bfa1">printColConfidence</a></td></tr>
<tr class="memdesc:a441eb8544c0ed9fe294a5b424390bfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print up to maxCols number from a flat floating point array.  <a href="#a441eb8544c0ed9fe294a5b424390bfa1">More...</a><br/></td></tr>
<tr class="separator:a441eb8544c0ed9fe294a5b424390bfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396042a9562bcba5e59dbee7d7174cfe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a396042a9562bcba5e59dbee7d7174cfe">printStates</a></td></tr>
<tr class="separator:a396042a9562bcba5e59dbee7d7174cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709d4435bcd6740dc6ec3e7f00db22e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a709d4435bcd6740dc6ec3e7f00db22e7">printOutput</a></td></tr>
<tr class="separator:a709d4435bcd6740dc6ec3e7f00db22e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3905cac4140e74a9104f73c5d4e3e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a0c3905cac4140e74a9104f73c5d4e3e8">printInput</a></td></tr>
<tr class="separator:a0c3905cac4140e74a9104f73c5d4e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a4e1a34899612f53f6cb3dd5d1b1cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04a4e1a34899612f53f6cb3dd5d1b1cb"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a04a4e1a34899612f53f6cb3dd5d1b1cb">printParameters</a></td></tr>
<tr class="memdesc:a04a4e1a34899612f53f6cb3dd5d1b1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the parameter settings for the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>. <br/></td></tr>
<tr class="separator:a04a4e1a34899612f53f6cb3dd5d1b1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c70fe37ce46de505202734e29024b33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a7c70fe37ce46de505202734e29024b33">printActiveIndices</a></td></tr>
<tr class="memdesc:a7c70fe37ce46de505202734e29024b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the list of [column, cellIdx] indices for each of the active cells in state.  <a href="#a7c70fe37ce46de505202734e29024b33">More...</a><br/></td></tr>
<tr class="separator:a7c70fe37ce46de505202734e29024b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c43bdeae098a44428ca09ceedd9ebe9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9c43bdeae098a44428ca09ceedd9ebe9">printComputeEnd</a></td></tr>
<tr class="memdesc:a9c43bdeae098a44428ca09ceedd9ebe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called at the end of inference to print out various diagnostic information based on the current verbosity level.  <a href="#a9c43bdeae098a44428ca09ceedd9ebe9">More...</a><br/></td></tr>
<tr class="separator:a9c43bdeae098a44428ca09ceedd9ebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4418ff760433bae0ad78958ccf4f03b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a4418ff760433bae0ad78958ccf4f03b2">printSegmentUpdates</a></td></tr>
<tr class="separator:a4418ff760433bae0ad78958ccf4f03b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e6440e3a594de9ed602db22383d5c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a15e6440e3a594de9ed602db22383d5c7">printCell</a></td></tr>
<tr class="separator:a15e6440e3a594de9ed602db22383d5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58973a31c42f39236fd24af328aa8d9a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a58973a31c42f39236fd24af328aa8d9a">printCells</a></td></tr>
<tr class="separator:a58973a31c42f39236fd24af328aa8d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0b2b773fd3f1189ca0abfe37ff30d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9e0b2b773fd3f1189ca0abfe37ff30d8">getNumSegmentsInCell</a></td></tr>
<tr class="separator:a9e0b2b773fd3f1189ca0abfe37ff30d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e8d3f2bd805e642c6fed0ac1bf94dc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a56e8d3f2bd805e642c6fed0ac1bf94dc">getNumSynapses</a></td></tr>
<tr class="separator:a56e8d3f2bd805e642c6fed0ac1bf94dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a47636806d70c6735477f9283f8043"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ae9a47636806d70c6735477f9283f8043">getNumStrongSynapses</a></td></tr>
<tr class="separator:ae9a47636806d70c6735477f9283f8043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aeb5411cadd95805b18cea47767afb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a20aeb5411cadd95805b18cea47767afb">getNumStrongSynapsesPerTimeSlot</a></td></tr>
<tr class="separator:a20aeb5411cadd95805b18cea47767afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc39b61e8c2a1d922f7e08f5105a35ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#adc39b61e8c2a1d922f7e08f5105a35ef">getNumSynapsesPerSegmentMax</a></td></tr>
<tr class="separator:adc39b61e8c2a1d922f7e08f5105a35ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64db2ad336d9b64ebbda3a96fc6275f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ad64db2ad336d9b64ebbda3a96fc6275f">getNumSynapsesPerSegmentAvg</a></td></tr>
<tr class="separator:ad64db2ad336d9b64ebbda3a96fc6275f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983b9a869bcda0767604a5ceefc7aa4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a983b9a869bcda0767604a5ceefc7aa4f">getNumSegments</a></td></tr>
<tr class="separator:a983b9a869bcda0767604a5ceefc7aa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf56e94a46c8aa3233a674e900f3c18"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a7cf56e94a46c8aa3233a674e900f3c18">getNumCells</a></td></tr>
<tr class="separator:a7cf56e94a46c8aa3233a674e900f3c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbfed5275a98b9a4c58d17df02b2c16"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#affbfed5275a98b9a4c58d17df02b2c16">getSegmentOnCell</a></td></tr>
<tr class="separator:affbfed5275a98b9a4c58d17df02b2c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894a7b0fcbbc22296fb5514c57262cc2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a894a7b0fcbbc22296fb5514c57262cc2">addToSegmentUpdates</a></td></tr>
<tr class="memdesc:a894a7b0fcbbc22296fb5514c57262cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a dated potential segment update.  <a href="#a894a7b0fcbbc22296fb5514c57262cc2">More...</a><br/></td></tr>
<tr class="separator:a894a7b0fcbbc22296fb5514c57262cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647ca40adc3716c715d6083db3574746"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a647ca40adc3716c715d6083db3574746">removeSegmentUpdate</a></td></tr>
<tr class="memdesc:a647ca40adc3716c715d6083db3574746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a segment update (called when seg update expires or is processed)  <a href="#a647ca40adc3716c715d6083db3574746">More...</a><br/></td></tr>
<tr class="separator:a647ca40adc3716c715d6083db3574746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30dfd26e3bf1ca1af7cef7687b9aea8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ae30dfd26e3bf1ca1af7cef7687b9aea8">computeOutput</a></td></tr>
<tr class="memdesc:ae30dfd26e3bf1ca1af7cef7687b9aea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes output for both learning and inference.  <a href="#ae30dfd26e3bf1ca1af7cef7687b9aea8">More...</a><br/></td></tr>
<tr class="separator:ae30dfd26e3bf1ca1af7cef7687b9aea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9774f901432111ba06fbf36ff7731ca4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9774f901432111ba06fbf36ff7731ca4">getActiveState</a></td></tr>
<tr class="memdesc:a9774f901432111ba06fbf36ff7731ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current active state.  <a href="#a9774f901432111ba06fbf36ff7731ca4">More...</a><br/></td></tr>
<tr class="separator:a9774f901432111ba06fbf36ff7731ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33b0631c4e0be709cbb62c4dacd86fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af33b0631c4e0be709cbb62c4dacd86fc">getPredictedState</a></td></tr>
<tr class="memdesc:af33b0631c4e0be709cbb62c4dacd86fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a numpy array, predictedCells, representing the current predicted state.  <a href="#af33b0631c4e0be709cbb62c4dacd86fc">More...</a><br/></td></tr>
<tr class="separator:af33b0631c4e0be709cbb62c4dacd86fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80037bed7820d7ac5c4e15d62f47099f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a80037bed7820d7ac5c4e15d62f47099f">predict</a></td></tr>
<tr class="memdesc:a80037bed7820d7ac5c4e15d62f47099f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gives the future predictions for &lt;nSteps&gt; timesteps starting from the current <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> state.  <a href="#a80037bed7820d7ac5c4e15d62f47099f">More...</a><br/></td></tr>
<tr class="separator:a80037bed7820d7ac5c4e15d62f47099f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8e7d8c479a58ed7a158c0a3c837eb4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a7c8e7d8c479a58ed7a158c0a3c837eb4">getAvgLearnedSeqLength</a></td></tr>
<tr class="separator:a7c8e7d8c479a58ed7a158c0a3c837eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9501253b8b964d3a01133e44b83a1f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9e9501253b8b964d3a01133e44b83a1f">inferBacktrack</a></td></tr>
<tr class="memdesc:a9e9501253b8b964d3a01133e44b83a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This "backtracks" our inference state, trying to see if we can lock onto the current set of inputs by assuming the sequence started up to N steps ago on start cells.  <a href="#a9e9501253b8b964d3a01133e44b83a1f">More...</a><br/></td></tr>
<tr class="separator:a9e9501253b8b964d3a01133e44b83a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa951aa1063a8a48de561fd69d718df8d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa951aa1063a8a48de561fd69d718df8d">inferPhase1</a></td></tr>
<tr class="memdesc:aa951aa1063a8a48de561fd69d718df8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the inference active state from the last set of predictions and the current bottom-up.  <a href="#aa951aa1063a8a48de561fd69d718df8d">More...</a><br/></td></tr>
<tr class="separator:aa951aa1063a8a48de561fd69d718df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e01f173cb6c44e084b9599cee2a7d26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a2e01f173cb6c44e084b9599cee2a7d26">inferPhase2</a></td></tr>
<tr class="memdesc:a2e01f173cb6c44e084b9599cee2a7d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Phase 2 for the inference state.  <a href="#a2e01f173cb6c44e084b9599cee2a7d26">More...</a><br/></td></tr>
<tr class="separator:a2e01f173cb6c44e084b9599cee2a7d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3bd7b67ffaa31f6f1a412f23ce7700"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9f3bd7b67ffaa31f6f1a412f23ce7700">updateInferenceState</a></td></tr>
<tr class="memdesc:a9f3bd7b67ffaa31f6f1a412f23ce7700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the inference state.  <a href="#a9f3bd7b67ffaa31f6f1a412f23ce7700">More...</a><br/></td></tr>
<tr class="separator:a9f3bd7b67ffaa31f6f1a412f23ce7700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467f1f63e9002efb5851f10f3fdf351b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a467f1f63e9002efb5851f10f3fdf351b">learnBacktrack</a></td></tr>
<tr class="memdesc:a467f1f63e9002efb5851f10f3fdf351b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This "backtracks" our learning state, trying to see if we can lock onto the current set of inputs by assuming the sequence started up to N steps ago on start cells.  <a href="#a467f1f63e9002efb5851f10f3fdf351b">More...</a><br/></td></tr>
<tr class="separator:a467f1f63e9002efb5851f10f3fdf351b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af240c1c01980b44ff07a881d670474cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af240c1c01980b44ff07a881d670474cd">learnPhase1</a></td></tr>
<tr class="memdesc:af240c1c01980b44ff07a881d670474cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the learning active state given the predicted state and the bottom-up input.  <a href="#af240c1c01980b44ff07a881d670474cd">More...</a><br/></td></tr>
<tr class="separator:af240c1c01980b44ff07a881d670474cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caae2299e9ed99f72d23ffc580a07a6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9caae2299e9ed99f72d23ffc580a07a6">learnPhase2</a></td></tr>
<tr class="memdesc:a9caae2299e9ed99f72d23ffc580a07a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the predicted segments given the current set of active cells.  <a href="#a9caae2299e9ed99f72d23ffc580a07a6">More...</a><br/></td></tr>
<tr class="separator:a9caae2299e9ed99f72d23ffc580a07a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6c46a018b575633138faf1bc7932e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a1d6c46a018b575633138faf1bc7932e8">updateLearningState</a></td></tr>
<tr class="memdesc:a1d6c46a018b575633138faf1bc7932e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the learning state.  <a href="#a1d6c46a018b575633138faf1bc7932e8">More...</a><br/></td></tr>
<tr class="separator:a1d6c46a018b575633138faf1bc7932e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2084b96999fb1734fd2f330bfa01a6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aaa2084b96999fb1734fd2f330bfa01a6">compute</a></td></tr>
<tr class="memdesc:aaa2084b96999fb1734fd2f330bfa01a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle one compute, possibly learning.  <a href="#aaa2084b96999fb1734fd2f330bfa01a6">More...</a><br/></td></tr>
<tr class="separator:aaa2084b96999fb1734fd2f330bfa01a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fb3e21db91c1a611c726a605593392"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a36fb3e21db91c1a611c726a605593392">infer</a></td></tr>
<tr class="separator:a36fb3e21db91c1a611c726a605593392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9339921d4a63f47fd93e7d7822f0e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aeb9339921d4a63f47fd93e7d7822f0e1">learn</a></td></tr>
<tr class="separator:aeb9339921d4a63f47fd93e7d7822f0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3ce3f2fe56edfe860415a04d1fcbac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#abe3ce3f2fe56edfe860415a04d1fcbac">updateSegmentDutyCycles</a></td></tr>
<tr class="memdesc:abe3ce3f2fe56edfe860415a04d1fcbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets called on every compute.  <a href="#abe3ce3f2fe56edfe860415a04d1fcbac">More...</a><br/></td></tr>
<tr class="separator:abe3ce3f2fe56edfe860415a04d1fcbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92abb4061612b92c2b3544778c6d1aba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a92abb4061612b92c2b3544778c6d1aba">columnConfidences</a></td></tr>
<tr class="memdesc:a92abb4061612b92c2b3544778c6d1aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the column confidences given the cell confidences.  <a href="#a92abb4061612b92c2b3544778c6d1aba">More...</a><br/></td></tr>
<tr class="separator:a92abb4061612b92c2b3544778c6d1aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c4d54611adb4ddf6b3a93662fa70f3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a39c4d54611adb4ddf6b3a93662fa70f3">topDownCompute</a></td></tr>
<tr class="memdesc:a39c4d54611adb4ddf6b3a93662fa70f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top-down compute - generate expected input given output of the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>.  <a href="#a39c4d54611adb4ddf6b3a93662fa70f3">More...</a><br/></td></tr>
<tr class="separator:a39c4d54611adb4ddf6b3a93662fa70f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fe1ce43827288e91312de2edd7529b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ad2fe1ce43827288e91312de2edd7529b">trimSegmentsInCell</a></td></tr>
<tr class="memdesc:ad2fe1ce43827288e91312de2edd7529b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method goes through a list of segments for a given cell and deletes all synapses whose permanence is less than minPermanence and deletes any segments that have less than minNumSyns synapses remaining.  <a href="#ad2fe1ce43827288e91312de2edd7529b">More...</a><br/></td></tr>
<tr class="separator:ad2fe1ce43827288e91312de2edd7529b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c45cce5611f4c5e48a20b856bdaedcf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6c45cce5611f4c5e48a20b856bdaedcf">trimSegments</a></td></tr>
<tr class="memdesc:a6c45cce5611f4c5e48a20b856bdaedcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method deletes all synapses whose permanence is less than minPermanence and deletes any segments that have less than minNumSyns synapses remaining.  <a href="#a6c45cce5611f4c5e48a20b856bdaedcf">More...</a><br/></td></tr>
<tr class="separator:a6c45cce5611f4c5e48a20b856bdaedcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdaae296c99be71860aca5ad43207a2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a4bdaae296c99be71860aca5ad43207a2">cleanUpdatesList</a></td></tr>
<tr class="memdesc:a4bdaae296c99be71860aca5ad43207a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any update that would be for the given col, cellIdx, segIdx.  <a href="#a4bdaae296c99be71860aca5ad43207a2">More...</a><br/></td></tr>
<tr class="separator:a4bdaae296c99be71860aca5ad43207a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58745380784df9f214440992f54ce73d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a58745380784df9f214440992f54ce73d">finishLearning</a></td></tr>
<tr class="memdesc:a58745380784df9f214440992f54ce73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when learning has been completed.  <a href="#a58745380784df9f214440992f54ce73d">More...</a><br/></td></tr>
<tr class="separator:a58745380784df9f214440992f54ce73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade172bde667f2d186b1d0b415652ebb6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ade172bde667f2d186b1d0b415652ebb6">checkPrediction2</a></td></tr>
<tr class="memdesc:ade172bde667f2d186b1d0b415652ebb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will replace checkPrediction.  <a href="#ade172bde667f2d186b1d0b415652ebb6">More...</a><br/></td></tr>
<tr class="separator:ade172bde667f2d186b1d0b415652ebb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909558a9636407cb33b13203cf54ba50"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a909558a9636407cb33b13203cf54ba50">isSegmentActive</a></td></tr>
<tr class="memdesc:a909558a9636407cb33b13203cf54ba50"><td class="mdescLeft">&#160;</td><td class="mdescRight">A segment is active if it has &gt;= activationThreshold connected synapses that are active due to activeState.  <a href="#a909558a9636407cb33b13203cf54ba50">More...</a><br/></td></tr>
<tr class="separator:a909558a9636407cb33b13203cf54ba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228afa402a0b7095f6e4e8d023cf80be"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a228afa402a0b7095f6e4e8d023cf80be">getSegmentActivityLevel</a></td></tr>
<tr class="memdesc:a228afa402a0b7095f6e4e8d023cf80be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine computes the activity level of a segment given activeState.  <a href="#a228afa402a0b7095f6e4e8d023cf80be">More...</a><br/></td></tr>
<tr class="separator:a228afa402a0b7095f6e4e8d023cf80be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7251ec281a0f23739a5c6141288afd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#abd7251ec281a0f23739a5c6141288afd">getBestMatchingCell</a></td></tr>
<tr class="memdesc:abd7251ec281a0f23739a5c6141288afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find weakly activated cell in column with at least minThreshold active synapses.  <a href="#abd7251ec281a0f23739a5c6141288afd">More...</a><br/></td></tr>
<tr class="separator:abd7251ec281a0f23739a5c6141288afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618cc112de4438a21831aa0f1a5c93c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a618cc112de4438a21831aa0f1a5c93c7">getBestMatchingSegment</a></td></tr>
<tr class="memdesc:a618cc112de4438a21831aa0f1a5c93c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">For the given cell, find the segment with the largest number of active synapses.  <a href="#a618cc112de4438a21831aa0f1a5c93c7">More...</a><br/></td></tr>
<tr class="separator:a618cc112de4438a21831aa0f1a5c93c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1777e5f796b8d82e07c718ef455a8446"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a1777e5f796b8d82e07c718ef455a8446">getCellForNewSegment</a></td></tr>
<tr class="memdesc:a1777e5f796b8d82e07c718ef455a8446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of a cell in this column which is a good candidate for adding a new segment.  <a href="#a1777e5f796b8d82e07c718ef455a8446">More...</a><br/></td></tr>
<tr class="separator:a1777e5f796b8d82e07c718ef455a8446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac0d8e2c8d99267355b96de06c574fe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aaac0d8e2c8d99267355b96de06c574fe">getSegmentActiveSynapses</a></td></tr>
<tr class="memdesc:aaac0d8e2c8d99267355b96de06c574fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a segmentUpdate data structure containing a list of proposed changes to segment s.  <a href="#aaac0d8e2c8d99267355b96de06c574fe">More...</a><br/></td></tr>
<tr class="separator:aaac0d8e2c8d99267355b96de06c574fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2707e91e7bdd3cf0ed78428fabeb1ca0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a2707e91e7bdd3cf0ed78428fabeb1ca0">chooseCellsToLearnFrom</a></td></tr>
<tr class="memdesc:a2707e91e7bdd3cf0ed78428fabeb1ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Choose n random cells to learn from.  <a href="#a2707e91e7bdd3cf0ed78428fabeb1ca0">More...</a><br/></td></tr>
<tr class="separator:a2707e91e7bdd3cf0ed78428fabeb1ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e3992827d8ae0acd972d62b1a0aa1e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a50e3992827d8ae0acd972d62b1a0aa1e">processSegmentUpdates</a></td></tr>
<tr class="memdesc:a50e3992827d8ae0acd972d62b1a0aa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through the list of accumulated segment updates and process them as follows:  <a href="#a50e3992827d8ae0acd972d62b1a0aa1e">More...</a><br/></td></tr>
<tr class="separator:a50e3992827d8ae0acd972d62b1a0aa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68892da693932494c9a7504546b59008"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a68892da693932494c9a7504546b59008">adaptSegment</a></td></tr>
<tr class="memdesc:a68892da693932494c9a7504546b59008"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function applies segment update information to a segment in a cell.  <a href="#a68892da693932494c9a7504546b59008">More...</a><br/></td></tr>
<tr class="separator:a68892da693932494c9a7504546b59008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db2768942b4303a72843f1cfa9f7c6d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a8db2768942b4303a72843f1cfa9f7c6d">getSegmentInfo</a></td></tr>
<tr class="memdesc:a8db2768942b4303a72843f1cfa9f7c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the distribution of segments, synapses and permanence values in the current <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>.  <a href="#a8db2768942b4303a72843f1cfa9f7c6d">More...</a><br/></td></tr>
<tr class="separator:a8db2768942b4303a72843f1cfa9f7c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4c7a521b8f1a0769c09bfa4a1fca7dab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a4c7a521b8f1a0769c09bfa4a1fca7dab">version</a></td></tr>
<tr class="separator:a4c7a521b8f1a0769c09bfa4a1fca7dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5789ad2e9767e779c43be42a40e23aaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a5789ad2e9767e779c43be42a40e23aaa">numberOfCols</a></td></tr>
<tr class="separator:a5789ad2e9767e779c43be42a40e23aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cc70f9f73fce65efdc47fc987681c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ab7cc70f9f73fce65efdc47fc987681c0">cellsPerColumn</a></td></tr>
<tr class="separator:ab7cc70f9f73fce65efdc47fc987681c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7538616ca92e88ce39e72503e43292"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a0a7538616ca92e88ce39e72503e43292">initialPerm</a></td></tr>
<tr class="separator:a0a7538616ca92e88ce39e72503e43292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d166246c82719443803b7fe8950bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6e7d166246c82719443803b7fe8950bf">connectedPerm</a></td></tr>
<tr class="separator:a6e7d166246c82719443803b7fe8950bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33420665fbd12a87b0cb5fdd63e66ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af33420665fbd12a87b0cb5fdd63e66ed">minThreshold</a></td></tr>
<tr class="separator:af33420665fbd12a87b0cb5fdd63e66ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657dae51622cf1fe8ac778c74247776a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a657dae51622cf1fe8ac778c74247776a">newSynapseCount</a></td></tr>
<tr class="separator:a657dae51622cf1fe8ac778c74247776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567df8f579d31f9f40af6744fb4d4ba7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a567df8f579d31f9f40af6744fb4d4ba7">permanenceInc</a></td></tr>
<tr class="separator:a567df8f579d31f9f40af6744fb4d4ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1c9f21c8238cd74a09674ea49128df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9c1c9f21c8238cd74a09674ea49128df">permanenceDec</a></td></tr>
<tr class="separator:a9c1c9f21c8238cd74a09674ea49128df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c24c3e1ff97ca483b69003dc6244ce2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a5c24c3e1ff97ca483b69003dc6244ce2">permanenceMax</a></td></tr>
<tr class="separator:a5c24c3e1ff97ca483b69003dc6244ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928d31317529982221f05c309265302a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a928d31317529982221f05c309265302a">globalDecay</a></td></tr>
<tr class="separator:a928d31317529982221f05c309265302a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad4b69670dd88928b266bc0e0905dbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9ad4b69670dd88928b266bc0e0905dbe">activationThreshold</a></td></tr>
<tr class="separator:a9ad4b69670dd88928b266bc0e0905dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221ed1a524b15ecad19609e068b2b907"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a221ed1a524b15ecad19609e068b2b907"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a221ed1a524b15ecad19609e068b2b907">doPooling</a></td></tr>
<tr class="memdesc:a221ed1a524b15ecad19609e068b2b907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to turn off pooling. <br/></td></tr>
<tr class="separator:a221ed1a524b15ecad19609e068b2b907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001c511d4dcaf944615d26deae86ae94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a001c511d4dcaf944615d26deae86ae94">segUpdateValidDuration</a></td></tr>
<tr class="separator:a001c511d4dcaf944615d26deae86ae94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a28b531738aef40c988e4c6e8693b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87a28b531738aef40c988e4c6e8693b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a87a28b531738aef40c988e4c6e8693b4">burnIn</a></td></tr>
<tr class="memdesc:a87a28b531738aef40c988e4c6e8693b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for evaluating the prediction score. <br/></td></tr>
<tr class="separator:a87a28b531738aef40c988e4c6e8693b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375a99dc3f54eaf17af661537858fbc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a375a99dc3f54eaf17af661537858fbc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a375a99dc3f54eaf17af661537858fbc1">collectStats</a></td></tr>
<tr class="memdesc:a375a99dc3f54eaf17af661537858fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, collect training/inference stats. <br/></td></tr>
<tr class="separator:a375a99dc3f54eaf17af661537858fbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31f6ed1e7e88c7cca70910409c6bbee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ab31f6ed1e7e88c7cca70910409c6bbee">seed</a></td></tr>
<tr class="separator:ab31f6ed1e7e88c7cca70910409c6bbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b1cc04ec204ba7f1507498beb1d460"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a97b1cc04ec204ba7f1507498beb1d460">verbosity</a></td></tr>
<tr class="separator:a97b1cc04ec204ba7f1507498beb1d460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b2d6c5da06c1791cb986a8725292fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a96b2d6c5da06c1791cb986a8725292fe">pamLength</a></td></tr>
<tr class="separator:a96b2d6c5da06c1791cb986a8725292fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a007327773fb2a6dbf261ac5de74090"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9a007327773fb2a6dbf261ac5de74090">maxAge</a></td></tr>
<tr class="separator:a9a007327773fb2a6dbf261ac5de74090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c1ad92a0be3a71161ced369dd6246"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a794c1ad92a0be3a71161ced369dd6246">maxInfBacktrack</a></td></tr>
<tr class="separator:a794c1ad92a0be3a71161ced369dd6246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2c0665c35d9e7f83570da9cb3dbd4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9a2c0665c35d9e7f83570da9cb3dbd4f">maxLrnBacktrack</a></td></tr>
<tr class="separator:a9a2c0665c35d9e7f83570da9cb3dbd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9271ee91f25d84c0609cca1db6669650"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9271ee91f25d84c0609cca1db6669650">maxSeqLength</a></td></tr>
<tr class="separator:a9271ee91f25d84c0609cca1db6669650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4d7fb994d3b5078fd91976fa7d9916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#add4d7fb994d3b5078fd91976fa7d9916">maxSegmentsPerCell</a></td></tr>
<tr class="separator:add4d7fb994d3b5078fd91976fa7d9916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e2bc6b3ff8c8d595266e9b0e335538"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a80e2bc6b3ff8c8d595266e9b0e335538">maxSynapsesPerSegment</a></td></tr>
<tr class="separator:a80e2bc6b3ff8c8d595266e9b0e335538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc72d03b0853feb6cb18a149e7937be9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#adc72d03b0853feb6cb18a149e7937be9">outputType</a></td></tr>
<tr class="separator:adc72d03b0853feb6cb18a149e7937be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34848255d456908a6db69c36b26928d5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a34848255d456908a6db69c36b26928d5">activeColumns</a></td></tr>
<tr class="separator:a34848255d456908a6db69c36b26928d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c69c6a1fc6af18d0e9a0773de196df5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c69c6a1fc6af18d0e9a0773de196df5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a3c69c6a1fc6af18d0e9a0773de196df5">cells</a></td></tr>
<tr class="memdesc:a3c69c6a1fc6af18d0e9a0773de196df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cells are indexed by column and index in the column Every self.cells[column][index] contains a list of segments Each segment is a structure of class <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_segment.html" title="The Segment class is a container for all of the segment variables and the synapses it owns...">Segment</a>. <br/></td></tr>
<tr class="separator:a3c69c6a1fc6af18d0e9a0773de196df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4329067f37000b0e0f978c2e452f78e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af4329067f37000b0e0f978c2e452f78e">lrnIterationIdx</a></td></tr>
<tr class="separator:af4329067f37000b0e0f978c2e452f78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466e4dee9c9ea2eeddbc5da206df39a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a466e4dee9c9ea2eeddbc5da206df39a2">iterationIdx</a></td></tr>
<tr class="separator:a466e4dee9c9ea2eeddbc5da206df39a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637cce30bd78360c76cfcab38ce4e94d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a637cce30bd78360c76cfcab38ce4e94d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a637cce30bd78360c76cfcab38ce4e94d">segID</a></td></tr>
<tr class="memdesc:a637cce30bd78360c76cfcab38ce4e94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unique segment id, so we can put segments in hashes <br/></td></tr>
<tr class="separator:a637cce30bd78360c76cfcab38ce4e94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac5aeb5541248288bdb589a576cf522"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#acac5aeb5541248288bdb589a576cf522">currentOutput</a></td></tr>
<tr class="separator:acac5aeb5541248288bdb589a576cf522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ccd0b330b6a85883127f4b65fa6c0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ad5ccd0b330b6a85883127f4b65fa6c0c">pamCounter</a></td></tr>
<tr class="memdesc:ad5ccd0b330b6a85883127f4b65fa6c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">pamCounter gets reset to pamLength whenever we detect that the learning state is making good predictions (at least half the columns predicted).  <a href="#ad5ccd0b330b6a85883127f4b65fa6c0c">More...</a><br/></td></tr>
<tr class="separator:ad5ccd0b330b6a85883127f4b65fa6c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f21b9f2e7f76fa1547c9382d10e7ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21f21b9f2e7f76fa1547c9382d10e7ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a21f21b9f2e7f76fa1547c9382d10e7ba">collectSequenceStats</a></td></tr>
<tr class="memdesc:a21f21b9f2e7f76fa1547c9382d10e7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">If True, the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> will compute a signature for each sequence. <br/></td></tr>
<tr class="separator:a21f21b9f2e7f76fa1547c9382d10e7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bee602e490f27d510977bb7a37f8548"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a3bee602e490f27d510977bb7a37f8548">resetCalled</a></td></tr>
<tr class="memdesc:a3bee602e490f27d510977bb7a37f8548"><td class="mdescLeft">&#160;</td><td class="mdescRight">This gets set when we receive a reset and cleared on the first compute following a reset.  <a href="#a3bee602e490f27d510977bb7a37f8548">More...</a><br/></td></tr>
<tr class="separator:a3bee602e490f27d510977bb7a37f8548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e14ea1ff6de42097f78b813eabe9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad9e14ea1ff6de42097f78b813eabe9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aad9e14ea1ff6de42097f78b813eabe9f">avgInputDensity</a></td></tr>
<tr class="memdesc:aad9e14ea1ff6de42097f78b813eabe9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">We keep track of the average input density here. <br/></td></tr>
<tr class="separator:aad9e14ea1ff6de42097f78b813eabe9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdd84f91fcb9731c6ca39ad671e3f49"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#abbdd84f91fcb9731c6ca39ad671e3f49">learnedSeqLength</a></td></tr>
<tr class="memdesc:abbdd84f91fcb9731c6ca39ad671e3f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the length of the sequence currently being learned.  <a href="#abbdd84f91fcb9731c6ca39ad671e3f49">More...</a><br/></td></tr>
<tr class="separator:abbdd84f91fcb9731c6ca39ad671e3f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a2d75f254ec693ab273fc4a229d29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a2c2a2d75f254ec693ab273fc4a229d29">avgLearnedSeqLength</a></td></tr>
<tr class="memdesc:a2c2a2d75f254ec693ab273fc4a229d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the moving average of all learned sequence length.  <a href="#a2c2a2d75f254ec693ab273fc4a229d29">More...</a><br/></td></tr>
<tr class="separator:a2c2a2d75f254ec693ab273fc4a229d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab1e636c02cbb449d709ccbbbcb4277"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6ab1e636c02cbb449d709ccbbbcb4277">segmentUpdates</a></td></tr>
<tr class="memdesc:a6ab1e636c02cbb449d709ccbbbcb4277"><td class="mdescLeft">&#160;</td><td class="mdescRight">We store the lists of segments updates, per cell, so that they can be applied later during learning, when the cell gets bottom-up activation.  <a href="#a6ab1e636c02cbb449d709ccbbbcb4277">More...</a><br/></td></tr>
<tr class="separator:a6ab1e636c02cbb449d709ccbbbcb4277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35612d7cc6005f9ec28222158b1b517b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a35612d7cc6005f9ec28222158b1b517b">cellConfidence</a></td></tr>
<tr class="separator:a35612d7cc6005f9ec28222158b1b517b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41610d8d6dcc19a225e3fac826f4c6c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a41610d8d6dcc19a225e3fac826f4c6c7">colConfidence</a></td></tr>
<tr class="separator:a41610d8d6dcc19a225e3fac826f4c6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14bfb6d5ae4fd788073445814da434e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa14bfb6d5ae4fd788073445814da434e">lrnActiveState</a></td></tr>
<tr class="separator:aa14bfb6d5ae4fd788073445814da434e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6621330596e52b65e319a57c62e19ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af6621330596e52b65e319a57c62e19ab">infActiveState</a></td></tr>
<tr class="separator:af6621330596e52b65e319a57c62e19ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3859ad503e39a2087913e93b6ef723"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#adb3859ad503e39a2087913e93b6ef723">lrnPredictedState</a></td></tr>
<tr class="separator:adb3859ad503e39a2087913e93b6ef723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a240a18eaa9520b2d8cc61a6121d6a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6a240a18eaa9520b2d8cc61a6121d6a6">infPredictedState</a></td></tr>
<tr class="separator:a6a240a18eaa9520b2d8cc61a6121d6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algorithm documentation. </p>
<p>The implementation here attempts to closely match the pseudocode in the documentation. This implementation does contain several additional bells and whistles such as a column confidence measure.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd><p class="startdd">Document other constructor parameters. </p>
<p class="enddd">Have some higher level flags for fast learning, HiLo, Pooling, etc. </p>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac775ee34451fdfa742b318538164070e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numberOfCols</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cellsPerColumn</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initialPerm</em> = <code>0.11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connectedPerm</em> = <code>0.50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minThreshold</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>newSynapseCount</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permanenceInc</em> = <code>0.10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permanenceDec</em> = <code>0.10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>permanenceMax</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>globalDecay</em> = <code>0.10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activationThreshold</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>doPooling</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segUpdateValidDuration</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>burnIn</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>collectStats</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>42</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>VERBOSITY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>checkSynapseConsistency</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pamLength</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxInfBacktrack</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxLrnBacktrack</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxAge</em> = <code>100000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxSeqLength</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxSegmentsPerCell</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxSynapsesPerSegment</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outputType</em> = <code>'normal'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pamLength</td><td>Number of time steps to remain in "Pay Attention Mode" after we detect we've reached the end of a learned sequence. Setting this to 0 disables PAM mode. When we are in PAM mode, we do not burst unpredicted columns during learning, which in turn prevents us from falling into a previously learned sequence for a while (until we run through another 'pamLength' steps). The advantge of PAM mode is that it requires fewer presentations to learn a set of sequences which share elements. The disadvantage of PAM mode is that if a learned sequence is immediately followed by set set of elements that should be learned as a 2nd sequence, the first pamLength elements of that sequence will not be learned as part of that 2nd sequence.</td></tr>
    <tr><td class="paramname">maxAge</td><td>Controls global decay. Global decay will only decay segments that have not been activated for maxAge iterations, and will only do the global decay loop every maxAge iterations. The default (maxAge=1) reverts to the behavior where global decay is applied every iteration to every segment. Using maxAge &gt; 1 can significantly speed up the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> when global decay is used.</td></tr>
    <tr><td class="paramname">maxSeqLength</td><td>If not 0, we will never learn more than maxSeqLength inputs in a row without starting over at start cells. This sets an upper bound on the length of learned sequences and thus is another means (besides maxAge and globalDecay) by which to limit how much the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> tries to learn.</td></tr>
    <tr><td class="paramname">maxSegmentsPerCell</td><td>The maximum number of segments allowed on a cell. This is used to turn on "fixed size CLA" mode. When in effect, globalDecay is not applicable and must be set to 0 and maxAge must be set to 0. When this is used (&gt; 0), maxSynapsesPerSegment must also be &gt; 0.</td></tr>
    <tr><td class="paramname">maxSynapsesPerSegment</td><td>The maximum number of synapses allowed in a segment. This is used to turn on "fixed size CLA" mode. When in effect, globalDecay is not applicable and must be set to 0 and maxAge must be set to 0. When this is used (&gt; 0), maxSegmentsPerCell must also be &gt; 0.</td></tr>
    <tr><td class="paramname">outputType</td><td>Can be one of the following: 'normal', 'activeState', 'activeState1CellPerCol'. 'normal': output the OR of the active and predicted state. 'activeState': output only the active state. 'activeState1CellPerCol': output only the active state, and at most 1 cell/column. If more than 1 cell is active in a column, the one with the highest confidence is sent up. Default is 'normal'.</td></tr>
    <tr><td class="paramname">doPooling</td><td>If True, pooling is enabled. False is the default.</td></tr>
    <tr><td class="paramname">burnIn</td><td>Used for evaluating the prediction score. Default is 2.</td></tr>
    <tr><td class="paramname">collectStats</td><td>If True, collect training / inference stats. Default is False. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a68892da693932494c9a7504546b59008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def adaptSegment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segUpdate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function applies segment update information to a segment in a cell. </p>
<p>Synapses on the active list get their permanence counts incremented by permanenceInc. All other synapses get their permanence counts decremented by permanenceDec.</p>
<p>We also increment the positiveActivations count of the segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segUpdate</td><td><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p_1_1_segment_update.html" title="Class used to carry instructions for updating a segment. ">SegmentUpdate</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if some synapses were decremented to 0 and the segment is a candidate for trimming </dd></dl>

</div>
</div>
<a class="anchor" id="a894a7b0fcbbc22296fb5514c57262cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def addToSegmentUpdates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segUpdate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a dated potential segment update. </p>
<p>The "date" (iteration index) is used later to determine whether the update is too old and should be forgotten. This is controlled by parameter segUpdateValidDuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>TODO: document </td></tr>
    <tr><td class="paramname">i</td><td>TODO: document </td></tr>
    <tr><td class="paramname">segUpdate</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade172bde667f2d186b1d0b415652ebb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def checkPrediction2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>patternNZs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>colConfidence</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>details</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will replace checkPrediction. </p>
<p>This function produces goodness-of-match scores for a set of input patterns, by checking for their presence in the current and predicted output of the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>. Returns a global count of the number of extra and missing bits, the confidence scores for each input pattern, and (if requested) the bits in each input pattern that were not present in the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>'s prediction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patternNZs</td><td>a list of input patterns that we want to check for. Each element is a list of the non-zeros in that pattern. </td></tr>
    <tr><td class="paramname">output</td><td>The output of the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>. If not specified, then use the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>'s current output. This can be specified if you are trying to check the prediction metric for an output from the past. </td></tr>
    <tr><td class="paramname">colConfidence</td><td>The column confidences. If not specified, then use the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>'s current self.colConfidence. This can be specified if you are trying to check the prediction metrics for an output from the past. </td></tr>
    <tr><td class="paramname">details</td><td>if True, also include details of missing bits per pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list containing: <pre class="fragment">      [
        totalExtras,
        totalMissing,
        [conf_1, conf_2, ...],
        [missing1, missing2, ...]
      ]
</pre></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">totalExtras</td><td>a global count of the number of 'extras', i.e. bits that are on in the current output but not in the or of all the passed in patterns </td></tr>
    <tr><td class="paramname">totalMissing</td><td>a global count of all the missing bits, i.e. the bits that are on in the or of the patterns, but not in the current output </td></tr>
    <tr><td class="paramname">conf_i</td><td>the confidence score for the i'th pattern inpatternsToCheck This consists of 3 items as a tuple: (predictionScore, posPredictionScore, negPredictionScore) </td></tr>
    <tr><td class="paramname">missing_i</td><td>the bits in the i'th pattern that were missing in the output. This list is only returned if details is True. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2707e91e7bdd3cf0ed78428fabeb1ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def chooseCellsToLearnFrom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Choose n random cells to learn from. </p>
<p>This function is called several times while learning with timeStep = t-1, so we cache the set of candidates for that case. It's also called once with timeStep = t, and we cache that set of candidates.</p>
<dl class="section return"><dt>Returns</dt><dd>tuple (column index, cell index). </dd></dl>

</div>
</div>
<a class="anchor" id="a4bdaae296c99be71860aca5ad43207a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def cleanUpdatesList </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cellIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes any update that would be for the given col, cellIdx, segIdx. </p>
<p>NOTE: logically, we need to do this when we delete segments, so that if an update refers to a segment that was just deleted, we also remove that update from the update list. However, I haven't seen it trigger in any of the unit tests yet, so it might mean that it's not needed and that situation doesn't occur, by construction. </p>

</div>
</div>
<a class="anchor" id="a92abb4061612b92c2b3544778c6d1aba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def columnConfidences </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cellConfidences</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the column confidences given the cell confidences. </p>
<p>If None is passed in for cellConfidences, it uses the stored cell confidences from the last compute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellConfidences</td><td>Cell confidences to use, or None to use the the current cell confidences.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Column confidence scores </dd></dl>

</div>
</div>
<a class="anchor" id="aaa2084b96999fb1734fd2f330bfa01a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def compute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bottomUpInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>enableLearn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>computeInfOutput</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle one compute, possibly learning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottomUpInput</td><td>The bottom-up input, typically from a spatial pooler </td></tr>
    <tr><td class="paramname">enableLearn</td><td>If true, perform learning </td></tr>
    <tr><td class="paramname">computeInfOutput</td><td>If None, default behavior is to disable the inference output when enableLearn is on. If true, compute the inference output If false, do not compute the inference output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TODO: document</dd></dl>
<p>It is an error to have both enableLearn and computeInfOutput set to False</p>
<p>By default, we don't compute the inference output when learning because it slows things down, but you can override this by passing in True for computeInfOutput </p>

</div>
</div>
<a class="anchor" id="ae30dfd26e3bf1ca1af7cef7687b9aea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def computeOutput </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes output for both learning and inference. </p>
<p>In both cases, the output is the boolean OR of activeState and predictedState at t. Stores currentOutput for checkPrediction. </p>

</div>
</div>
<a class="anchor" id="a58745380784df9f214440992f54ce73d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def finishLearning </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when learning has been completed. </p>
<p>This method just calls <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6c45cce5611f4c5e48a20b856bdaedcf" title="This method deletes all synapses whose permanence is less than minPermanence and deletes any segments...">trimSegments()</a>. (finishLearning is here for backward compatibility) </p>

</div>
</div>
<a class="anchor" id="a9774f901432111ba06fbf36ff7731ca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getActiveState </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current active state. </p>
<p>This is called by the node to obtain the sequence output of the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>. </p>

</div>
</div>
<a class="anchor" id="a7c8e7d8c479a58ed7a158c0a3c837eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getAvgLearnedSeqLength </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Moving average of learned sequence length </dd></dl>

</div>
</div>
<a class="anchor" id="abd7251ec281a0f23739a5c6141288afd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getBestMatchingCell </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find weakly activated cell in column with at least minThreshold active synapses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>which column to look at </td></tr>
    <tr><td class="paramname">activeState</td><td>the active cells </td></tr>
    <tr><td class="paramname">minThreshold</td><td>minimum number of synapses required</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple (cellIdx, segment, numActiveSynapses) </dd></dl>

</div>
</div>
<a class="anchor" id="a618cc112de4438a21831aa0f1a5c93c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getBestMatchingSegment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For the given cell, find the segment with the largest number of active synapses. </p>
<p>This routine is aggressive in finding the best match. The permanence value of synapses is allowed to be below connectedPerm. The number of active synapses is allowed to be below activationThreshold, but must be above minThreshold. The routine returns the segment index. If no segments are found, then an index of -1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>TODO: document </td></tr>
    <tr><td class="paramname">i</td><td>TODO: document </td></tr>
    <tr><td class="paramname">activeState</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1777e5f796b8d82e07c718ef455a8446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getCellForNewSegment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>colIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of a cell in this column which is a good candidate for adding a new segment. </p>
<p>When we have fixed size resources in effect, we insure that we pick a cell which does not already have the max number of allowed segments. If none exists, we choose the least used segment in the column to re-allocate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colIdx</td><td>which column to look at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cell index </dd></dl>

</div>
</div>
<a class="anchor" id="a7cf56e94a46c8aa3233a674e900f3c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getNumCells </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of cells </dd></dl>

</div>
</div>
<a class="anchor" id="a983b9a869bcda0767604a5ceefc7aa4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getNumSegments </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of segments </dd></dl>

</div>
</div>
<a class="anchor" id="a9e0b2b773fd3f1189ca0abfe37ff30d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getNumSegmentsInCell </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>column index </td></tr>
    <tr><td class="paramname">i</td><td>cell index within column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of synapses in cell (c, i) </dd></dl>

</div>
</div>
<a class="anchor" id="ae9a47636806d70c6735477f9283f8043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getNumStrongSynapses </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>implement this, it is used by the node's getParameter() call </dd></dl>

</div>
</div>
<a class="anchor" id="a20aeb5411cadd95805b18cea47767afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getNumStrongSynapsesPerTimeSlot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>implement this, it is used by the node's getParameter() call </dd></dl>

</div>
</div>
<a class="anchor" id="a56e8d3f2bd805e642c6fed0ac1bf94dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getNumSynapses </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the total number of synapses </dd></dl>

</div>
</div>
<a class="anchor" id="ad64db2ad336d9b64ebbda3a96fc6275f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getNumSynapsesPerSegmentAvg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the average number of synapses per segment </dd></dl>

</div>
</div>
<a class="anchor" id="adc39b61e8c2a1d922f7e08f5105a35ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getNumSynapsesPerSegmentMax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>implement this, it is used by the node's getParameter() call, it should return the max # of synapses seen in any one segment.</dd></dl>

</div>
</div>
<a class="anchor" id="af33b0631c4e0be709cbb62c4dacd86fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getPredictedState </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a numpy array, predictedCells, representing the current predicted state. </p>
<p>predictedCells[c][i] represents the state of the i'th cell in the c'th column.</p>
<dl class="section return"><dt>Returns</dt><dd>numpy array of predicted cells, representing the current predicted state. predictedCells[c][i] represents the state of the i'th cell in the c'th column. </dd></dl>

</div>
</div>
<a class="anchor" id="aaac0d8e2c8d99267355b96de06c574fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getSegmentActiveSynapses </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>newSynapses</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a segmentUpdate data structure containing a list of proposed changes to segment s. </p>
<p>Let activeSynapses be the list of active synapses where the originating cells have their activeState output = 1 at time step t. (This list is empty if s is None since the segment doesn't exist.) newSynapses is an optional argument that defaults to false. If newSynapses is true, then newSynapseCount - len(activeSynapses) synapses are added to activeSynapses. These synapses are randomly chosen from the set of cells that have learnState = 1 at timeStep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>TODO: document </td></tr>
    <tr><td class="paramname">i</td><td>TODO: document </td></tr>
    <tr><td class="paramname">s</td><td>TODO: document </td></tr>
    <tr><td class="paramname">activeState</td><td>TODO: document </td></tr>
    <tr><td class="paramname">newSynapses</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a228afa402a0b7095f6e4e8d023cf80be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getSegmentActivityLevel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>connectedSynapsesOnly</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This routine computes the activity level of a segment given activeState. </p>
<p>It can tally up only connected synapses (permanence &gt;= connectedPerm), or all the synapses of the segment, at either t or t-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>TODO: document </td></tr>
    <tr><td class="paramname">activeState</td><td>TODO: document </td></tr>
    <tr><td class="paramname">connectedSynapsesOnly</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8db2768942b4303a72843f1cfa9f7c6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getSegmentInfo </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>collectActiveData</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns information about the distribution of segments, synapses and permanence values in the current <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>. </p>
<p>If requested, also returns information regarding the number of currently active segments and synapses.</p>
<dl class="section return"><dt>Returns</dt><dd>tuple described below: <pre class="fragment">(
  nSegments,
  nSynapses,
  nActiveSegs,
  nActiveSynapses,
  distSegSizes,
  distNSegsPerCell,
  distPermValues,
  distAges
)
</pre></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nSegments</td><td>total number of segments </td></tr>
    <tr><td class="paramname">nSynapses</td><td>total number of synapses </td></tr>
    <tr><td class="paramname">nActiveSegs</td><td>total no. of active segments (0 if collectActiveData is False) </td></tr>
    <tr><td class="paramname">nActiveSynapses</td><td>total no. of active synapses 0 if collectActiveData is False </td></tr>
    <tr><td class="paramname">distSegSizes</td><td>a dict where d[n] = number of segments with n synapses </td></tr>
    <tr><td class="paramname">distNSegsPerCell</td><td>a dict where d[n] = number of cells with n segments </td></tr>
    <tr><td class="paramname">distPermValues</td><td>a dict where d[p] = number of synapses with perm = p/10 </td></tr>
    <tr><td class="paramname">distAges</td><td>a list of tuples (ageRange, numSegments) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affbfed5275a98b9a4c58d17df02b2c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getSegmentOnCell </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>column index </td></tr>
    <tr><td class="paramname">i</td><td>cell index in column </td></tr>
    <tr><td class="paramname">segIdx</td><td>TODO: document</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list representing the the segment on cell (c, i) with index sidx.</dd></dl>
<p>Returns the segment as following list: </p>
<pre class="fragment">[  [segmentID, sequenceSegmentFlag, positiveActivations,
    totalActivations, lastActiveIteration,
    lastPosDutyCycle, lastPosDutyCycleIteration],
   [col1, idx1, perm1],
   [col2, idx2, perm2], ...
]
</pre><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">segmentId</td><td>TODO: document </td></tr>
    <tr><td class="paramname">sequenceSegmentFlag</td><td>TODO: document </td></tr>
    <tr><td class="paramname">positiveActivations</td><td>TODO: document </td></tr>
    <tr><td class="paramname">totalActivations</td><td>TODO: document </td></tr>
    <tr><td class="paramname">lastActiveIteration</td><td>TODO: document </td></tr>
    <tr><td class="paramname">lastPosDutyCycle</td><td>TODO: document </td></tr>
    <tr><td class="paramname">lastPosDutyCycleIteration</td><td>TODO: document </td></tr>
    <tr><td class="paramname">[col1,idx1,perm1]</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ac6450a1abccd3bc55ef2691a9a60cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def getStats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the current learning and inference stats. </p>
<p>This returns a dict containing all the learning and inference stats we have collected since the last <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a3c5c0d71cd4c827f01109b3801194b5a" title="Reset the learning and inference stats. ">resetStats()</a>. If <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a375a99dc3f54eaf17af661537858fbc1">collectStats</a> is False, then None is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>dict</dd></dl>
<p>The following keys are returned in the dict when <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a375a99dc3f54eaf17af661537858fbc1">collectStats</a> is True:</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nPredictions</td><td>the number of predictions. This is the total number of inferences excluding burn-in and the last inference.</td></tr>
    <tr><td class="paramname">curPredictionScore</td><td>the score for predicting the current input (predicted during the previous inference)</td></tr>
    <tr><td class="paramname">curMissing</td><td>the number of bits in the current input that were not predicted to be on.</td></tr>
    <tr><td class="paramname">curExtra</td><td>the number of bits in the predicted output that are not in the next input</td></tr>
    <tr><td class="paramname">predictionScoreTotal</td><td>the sum of every prediction score to date</td></tr>
    <tr><td class="paramname">predictionScoreAvg</td><td>predictionScoreTotal / nPredictions</td></tr>
    <tr><td class="paramname">pctMissingTotal</td><td>the total number of bits that were missed over all predictions</td></tr>
    <tr><td class="paramname">pctMissingAvg</td><td>pctMissingTotal / nPredictions</td></tr>
    <tr><td class="paramname">prevSequenceSignature</td><td>signature for the sequence immediately preceding the last reset. 'None' if collectSequenceStats is False </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36fb3e21db91c1a611c726a605593392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def infer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bottomUpInput</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a9e9501253b8b964d3a01133e44b83a1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def inferBacktrack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This "backtracks" our inference state, trying to see if we can lock onto the current set of inputs by assuming the sequence started up to N steps ago on start cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeColumns</td><td>The list of active column indices</td></tr>
  </table>
  </dd>
</dl>
<p>This will adjust <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af6621330596e52b65e319a57c62e19ab">infActiveState</a>['t'] if it does manage to lock on to a sequence that started earlier. It will also compute infPredictedState['t'] based on the possibly updated <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af6621330596e52b65e319a57c62e19ab">infActiveState</a>['t'], so there is no need to call <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a2e01f173cb6c44e084b9599cee2a7d26" title="Phase 2 for the inference state. ">inferPhase2()</a> after calling <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a9e9501253b8b964d3a01133e44b83a1f" title="This &quot;backtracks&quot; our inference state, trying to see if we can lock onto the current set of inputs by...">inferBacktrack()</a>.</p>
<p>This looks at:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af6621330596e52b65e319a57c62e19ab">infActiveState</a>['t']</li>
</ul>
<p>This updates/modifies:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af6621330596e52b65e319a57c62e19ab">infActiveState</a>['t']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6a240a18eaa9520b2d8cc61a6121d6a6">infPredictedState</a>['t']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a41610d8d6dcc19a225e3fac826f4c6c7">colConfidence</a>['t']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a35612d7cc6005f9ec28222158b1b517b">cellConfidence</a>['t']</li>
</ul>
<h2>How it works: </h2>
<p>This method gets called from updateInferenceState when we detect either of the following two conditions:</p>
<ol type="1">
<li>The current bottom-up input had too many un-expected columns</li>
<li>We fail to generate a sufficient number of predicted columns for the next time step.</li>
</ol>
<p>Either of these two conditions indicate that we have fallen out of a learned sequence.</p>
<p>Rather than simply "giving up" and bursting on the unexpected input columns, a better approach is to see if perhaps we are in a sequence that started a few steps ago. The real world analogy is that you are driving along and suddenly hit a dead-end, you will typically go back a few turns ago and pick up again from a familiar intersection.</p>
<p>This back-tracking goes hand in hand with our learning methodology, which always tries to learn again from start cells after it loses context. This results in a network that has learned multiple, overlapping paths through the input data, each starting at different points. The lower the global decay and the more repeatability in the data, the longer each of these paths will end up being.</p>
<p>The goal of this function is to find out which starting point in the past leads to the current input with the most context as possible. This gives us the best chance of predicting accurately going forward. Consider the following example, where you have learned the following sub-sequences which have the given frequencies: </p>
<pre class="fragment">              ? - Q - C - D - E      10X      seq 0
              ? - B - C - D - F      1X       seq 1
              ? - B - C - H - I      2X       seq 2
              ? - B - C - D - F      3X       seq 3
      ? - Z - A - B - C - D - J      2X       seq 4
      ? - Z - A - B - C - H - I      1X       seq 5
      ? - Y - A - B - C - D - F      3X       seq 6

    ----------------------------------------
  W - X - Z - A - B - C - D          &lt;= input history
                          ^
                          current time step
</pre><p>Suppose, in the current time step, the input pattern is D and you have not predicted D, so you need to backtrack. Suppose we can backtrack up to 6 steps in the past, which path should we choose? From the table above, we can see that the correct answer is to assume we are in seq 4. How do we implement the backtrack to give us this right answer? The current implementation takes the following approach:</p>
<ol type="1">
<li>Start from the farthest point in the past.</li>
<li>For each starting point S, calculate the confidence of the current input, conf(startingPoint=S), assuming we followed that sequence. Note that we must have learned at least one sequence that starts at point S.</li>
<li>If conf(startingPoint=S) is significantly different from conf(startingPoint=S-1), then choose S-1 as the starting point.</li>
</ol>
<p>The assumption here is that starting point S-1 is the starting point of a learned sub-sequence that includes the current input in it's path and that started the longest ago. It thus has the most context and will be the best predictor going forward.</p>
<p>From the statistics in the above table, we can compute what the confidences will be for each possible starting point: </p>
<pre class="fragment">startingPoint           confidence of D
-----------------------------------------
B (t-2)               4/6  = 0.667   (seq 1,3)/(seq 1,2,3)
Z (t-4)               2/3  = 0.667   (seq 4)/(seq 4,5)
</pre><p>First of all, we do not compute any confidences at starting points t-1, t-3, t-5, t-6 because there are no learned sequences that start at those points.</p>
<p>Notice here that Z is the starting point of the longest sub-sequence leading up to the current input. Event though starting at t-2 and starting at t-4 give the same confidence value, we choose the sequence starting at t-4 because it gives the most context, and it mirrors the way that learning extends sequences. </p>

</div>
</div>
<a class="anchor" id="aa951aa1063a8a48de561fd69d718df8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def inferPhase1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>useStartCells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the inference active state from the last set of predictions and the current bottom-up. </p>
<p>This looks at:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6a240a18eaa9520b2d8cc61a6121d6a6">infPredictedState</a>['t-1'] This modifies:</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af6621330596e52b65e319a57c62e19ab">infActiveState</a>['t']</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeColumns</td><td>list of active bottom-ups </td></tr>
    <tr><td class="paramname">useStartCells</td><td>If true, ignore previous predictions and simply turn on the start cells in the active columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the current input was sufficiently predicted, OR if we started over on startCells. False indicates that the current input was NOT predicted, and we are now bursting on most columns. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e01f173cb6c44e084b9599cee2a7d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def inferPhase2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Phase 2 for the inference state. </p>
<p>The computes the predicted state, then checks to insure that the predicted state is not over-saturated, i.e. look too close like a burst. This indicates that there were so many separate paths learned from the current input columns to the predicted input columns that bursting on the current input columns is most likely generated mix and match errors on cells in the predicted columns. If we detect this situation, we instead turn on only the start cells in the current active columns and re-generate the predicted state from those.</p>
<dl class="section return"><dt>Returns</dt><dd>True if we have a decent guess as to the next input. Returing False from here indicates to the caller that we have reached the end of a learned sequence.</dd></dl>
<p>This looks at:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#af6621330596e52b65e319a57c62e19ab">infActiveState</a>['t']</li>
</ul>
<p>This modifies:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6a240a18eaa9520b2d8cc61a6121d6a6">infPredictedState</a>['t']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a41610d8d6dcc19a225e3fac826f4c6c7">colConfidence</a>['t']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a35612d7cc6005f9ec28222158b1b517b">cellConfidence</a>['t'] </li>
</ul>

</div>
</div>
<a class="anchor" id="a909558a9636407cb33b13203cf54ba50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def isSegmentActive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A segment is active if it has &gt;= activationThreshold connected synapses that are active due to activeState. </p>
<p>Notes: studied various cutoffs, none of which seem to be worthwhile list comprehension didn't help either</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seg</td><td>TODO: document </td></tr>
    <tr><td class="paramname">activeState</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb9339921d4a63f47fd93e7d7822f0e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def learn </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bottomUpInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>computeInfOutput</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a467f1f63e9002efb5851f10f3fdf351b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def learnBacktrack </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This "backtracks" our learning state, trying to see if we can lock onto the current set of inputs by assuming the sequence started up to N steps ago on start cells. </p>
<p>This will adjust <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa14bfb6d5ae4fd788073445814da434e">lrnActiveState</a>['t'] if it does manage to lock on to a sequence that started earlier.</p>
<dl class="section return"><dt>Returns</dt><dd>&gt;0 if we managed to lock on to a sequence that started earlier. The value returned is how many steps in the past we locked on. If 0 is returned, the caller needs to change active state to start on start cells.</dd></dl>
<h2>How it works: </h2>
<p>This method gets called from updateLearningState when we detect either of the following two conditions:</p>
<ol type="1">
<li>Our PAM counter (<a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#ad5ccd0b330b6a85883127f4b65fa6c0c">pamCounter</a>) expired</li>
<li>We reached the max allowed learned sequence length</li>
</ol>
<p>Either of these two conditions indicate that we want to start over on start cells.</p>
<p>Rather than start over on start cells on the current input, we can accelerate learning by backtracking a few steps ago and seeing if perhaps a sequence we already at least partially know already started.</p>
<p>This updates/modifies:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa14bfb6d5ae4fd788073445814da434e">lrnActiveState</a>['t']</li>
</ul>
<p>This trashes:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa14bfb6d5ae4fd788073445814da434e">lrnActiveState</a>['t-1']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#adb3859ad503e39a2087913e93b6ef723">lrnPredictedState</a>['t']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#adb3859ad503e39a2087913e93b6ef723">lrnPredictedState</a>['t-1'] </li>
</ul>

</div>
</div>
<a class="anchor" id="af240c1c01980b44ff07a881d670474cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def learnPhase1 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the learning active state given the predicted state and the bottom-up input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeColumns</td><td>list of active bottom-ups </td></tr>
    <tr><td class="paramname">readOnly</td><td>True if being called from backtracking logic. This tells us not to increment any segment duty cycles or queue up any updates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the current input was sufficiently predicted, OR if we started over on startCells. False indicates that the current input was NOT predicted, well enough to consider it as "inSequence"</dd></dl>
<p>This looks at:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa14bfb6d5ae4fd788073445814da434e">lrnActiveState</a>['t-1']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#adb3859ad503e39a2087913e93b6ef723">lrnPredictedState</a>['t-1']</li>
</ul>
<p>This modifies:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa14bfb6d5ae4fd788073445814da434e">lrnActiveState</a>['t']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa14bfb6d5ae4fd788073445814da434e">lrnActiveState</a>['t-1'] </li>
</ul>

</div>
</div>
<a class="anchor" id="a9caae2299e9ed99f72d23ffc580a07a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def learnPhase2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>readOnly</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the predicted segments given the current set of active cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readOnly</td><td>True if being called from backtracking logic. This tells us not to increment any segment duty cycles or queue up any updates.</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the lrnPredictedState['t'] and queues up any segments that became active (and the list of active synapses for each segment) into the segmentUpdates queue</p>
<p>This looks at:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aa14bfb6d5ae4fd788073445814da434e">lrnActiveState</a>['t']</li>
</ul>
<p>This modifies:</p>
<ul>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#adb3859ad503e39a2087913e93b6ef723">lrnPredictedState</a>['t']</li>
<li><a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#a6ab1e636c02cbb449d709ccbbbcb4277">segmentUpdates</a> </li>
</ul>

</div>
</div>
<a class="anchor" id="a80037bed7820d7ac5c4e15d62f47099f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def predict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nSteps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gives the future predictions for &lt;nSteps&gt; timesteps starting from the current <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> state. </p>
<p>The <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> is returned to its original state at the end before returning.</p>
<ol type="1">
<li>We save the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> state.</li>
<li>Loop for nSteps<ol type="a">
<li>Turn-on with lateral support from the current active cells</li>
<li>Set the predicted cells as the next step's active cells. This step in learn and infer methods use input here to correct the predictions. We don't use any input here.</li>
</ol>
</li>
<li>Revert back the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> state to the time before prediction</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSteps</td><td>The number of future time steps to be predicted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>all the future predictions - a numpy array of type "float32" and shape (nSteps, numberOfCols). The ith row gives the tp prediction for each column at a future timestep (t+i+1). </dd></dl>

</div>
</div>
<a class="anchor" id="a7c70fe37ce46de505202734e29024b33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printActiveIndices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>andValues</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the list of [column, cellIdx] indices for each of the active cells in state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>TODO: document </td></tr>
    <tr><td class="paramname">andValues</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15e6440e3a594de9ed602db22383d5c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printCell </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>onlyActiveSegments</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a58973a31c42f39236fd24af328aa8d9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printCells </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predictedOnly</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a441eb8544c0ed9fe294a5b424390bfa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printColConfidence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxCols</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print up to maxCols number from a flat floating point array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aState</td><td>TODO: document </td></tr>
    <tr><td class="paramname">maxCols</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c43bdeae098a44428ca09ceedd9ebe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printComputeEnd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>learn</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called at the end of inference to print out various diagnostic information based on the current verbosity level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>TODO: document </td></tr>
    <tr><td class="paramname">learn</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="addce5cc48d11e8822767781522d64621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printConfidence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxCols</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a floating point array that is the same shape as activeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aState</td><td>TODO: document </td></tr>
    <tr><td class="paramname">maxCols</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c3905cac4140e74a9104f73c5d4e3e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printInput </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a709d4435bcd6740dc6ec3e7f00db22e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printOutput </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a4418ff760433bae0ad78958ccf4f03b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printSegmentUpdates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a8a350a9416a820ed41d18eb248c2b76b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printState </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an integer array that is the same shape as activeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aState</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a396042a9562bcba5e59dbee7d7174cfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def printStates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>printPrevious</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>printLearnState</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a50e3992827d8ae0acd972d62b1a0aa1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def processSegmentUpdates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Go through the list of accumulated segment updates and process them as follows: </p>
<p>if the segment update is too old, remove the update else if the cell received bottom-up, update its permanences else if it's still being predicted, leave it in the queue else remove it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeColumns</td><td>TODO: document </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a647ca40adc3716c715d6083db3574746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def removeSegmentUpdate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>updateInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a segment update (called when seg update expires or is processed) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updateInfo</td><td>tuple (creationDate, <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p_1_1_segment_update.html" title="Class used to carry instructions for updating a segment. ">SegmentUpdate</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13463c21005956b949860ac0eda9b3e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def reset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the state of all cells. </p>
<p>This is normally used between sequences while training. All internal states are reset to 0. </p>

</div>
</div>
<a class="anchor" id="a3c5c0d71cd4c827f01109b3801194b5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def resetStats </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the learning and inference stats. </p>
<p>This will usually be called by user code at the start of each inference run (for a particular data set). </p>

</div>
</div>
<a class="anchor" id="a39c4d54611adb4ddf6b3a93662fa70f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def topDownCompute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>topDownIn</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Top-down compute - generate expected input given output of the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topDownIn</td><td>top down input from the level above us</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>best estimate of the <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html" title="Class implementing the temporal pooler algorithm as described in the published Cortical Learning Algo...">TP</a> input that would have generated bottomUpOut. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c45cce5611f4c5e48a20b856bdaedcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def trimSegments </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minPermanence</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minNumSyns</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method deletes all synapses whose permanence is less than minPermanence and deletes any segments that have less than minNumSyns synapses remaining. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPermanence</td><td>Any syn whose permamence is 0 or &lt; minPermanence will be deleted. If None is passed in, then self.connectedPerm is used. </td></tr>
    <tr><td class="paramname">minNumSyns</td><td>Any segment with less than minNumSyns synapses remaining in it will be deleted. If None is passed in, then self.activationThreshold is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple (numSegsRemoved, numSynsRemoved) </dd></dl>

</div>
</div>
<a class="anchor" id="ad2fe1ce43827288e91312de2edd7529b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def trimSegmentsInCell </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>colIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cellIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>segList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minPermanence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minNumSyns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method goes through a list of segments for a given cell and deletes all synapses whose permanence is less than minPermanence and deletes any segments that have less than minNumSyns synapses remaining. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colIdx</td><td>Column index </td></tr>
    <tr><td class="paramname">cellIdx</td><td>Cell index within the column </td></tr>
    <tr><td class="paramname">segList</td><td>List of segment references </td></tr>
    <tr><td class="paramname">minPermanence</td><td>Any syn whose permamence is 0 or &lt; minPermanence will be deleted. </td></tr>
    <tr><td class="paramname">minNumSyns</td><td>Any segment with less than minNumSyns synapses remaining in it will be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple (numSegsRemoved, numSynsRemoved) </dd></dl>

</div>
</div>
<a class="anchor" id="a9f3bd7b67ffaa31f6f1a412f23ce7700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def updateInferenceState </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the inference state. </p>
<p>Called from <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aaa2084b96999fb1734fd2f330bfa01a6" title="Handle one compute, possibly learning. ">compute()</a> on every iteration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeColumns</td><td>The list of active column indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d6c46a018b575633138faf1bc7932e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def updateLearningState </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>activeColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the learning state. </p>
<p>Called from <a class="el" href="classnupic_1_1research_1_1_t_p_1_1_t_p.html#aaa2084b96999fb1734fd2f330bfa01a6" title="Handle one compute, possibly learning. ">compute()</a> on every iteration </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activeColumns</td><td>List of active column indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abe3ce3f2fe56edfe860415a04d1fcbac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def updateSegmentDutyCycles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets called on every compute. </p>
<p>It determines if it's time to update the segment duty cycles. Since the duty cycle calculation is a moving average based on a tiered alpha, it is important that we update all segments on each tier boundary. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a9ad4b69670dd88928b266bc0e0905dbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">activationThreshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a34848255d456908a6db69c36b26928d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">activeColumns</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a2c2a2d75f254ec693ab273fc4a229d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">avgLearnedSeqLength</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keeps track of the moving average of all learned sequence length. </p>

</div>
</div>
<a class="anchor" id="a35612d7cc6005f9ec28222158b1b517b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cellConfidence</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="ab7cc70f9f73fce65efdc47fc987681c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cellsPerColumn</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a41610d8d6dcc19a225e3fac826f4c6c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">colConfidence</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a6e7d166246c82719443803b7fe8950bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">connectedPerm</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="acac5aeb5541248288bdb589a576cf522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">currentOutput</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a928d31317529982221f05c309265302a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">globalDecay</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="af6621330596e52b65e319a57c62e19ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">infActiveState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000043">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a6a240a18eaa9520b2d8cc61a6121d6a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">infPredictedState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000045">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a0a7538616ca92e88ce39e72503e43292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">initialPerm</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a466e4dee9c9ea2eeddbc5da206df39a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">iterationIdx</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="abbdd84f91fcb9731c6ca39ad671e3f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">learnedSeqLength</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Keeps track of the length of the sequence currently being learned. </p>

</div>
</div>
<a class="anchor" id="aa14bfb6d5ae4fd788073445814da434e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lrnActiveState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000042">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="af4329067f37000b0e0f978c2e452f78e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lrnIterationIdx</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="adb3859ad503e39a2087913e93b6ef723"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lrnPredictedState</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000044">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a9a007327773fb2a6dbf261ac5de74090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">maxAge</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a794c1ad92a0be3a71161ced369dd6246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">maxInfBacktrack</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a9a2c0665c35d9e7f83570da9cb3dbd4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">maxLrnBacktrack</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="add4d7fb994d3b5078fd91976fa7d9916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">maxSegmentsPerCell</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a9271ee91f25d84c0609cca1db6669650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">maxSeqLength</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a80e2bc6b3ff8c8d595266e9b0e335538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">maxSynapsesPerSegment</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="af33420665fbd12a87b0cb5fdd63e66ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">minThreshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a657dae51622cf1fe8ac778c74247776a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">newSynapseCount</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a5789ad2e9767e779c43be42a40e23aaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numberOfCols</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="adc72d03b0853feb6cb18a149e7937be9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">outputType</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="ad5ccd0b330b6a85883127f4b65fa6c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pamCounter</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pamCounter gets reset to pamLength whenever we detect that the learning state is making good predictions (at least half the columns predicted). </p>
<p>Whenever we do not make a good prediction, we decrement pamCounter. When pamCounter reaches 0, we start the learn state over again at start cells. </p>

</div>
</div>
<a class="anchor" id="a96b2d6c5da06c1791cb986a8725292fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pamLength</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a9c1c9f21c8238cd74a09674ea49128df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">permanenceDec</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a567df8f579d31f9f40af6744fb4d4ba7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">permanenceInc</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a5c24c3e1ff97ca483b69003dc6244ce2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">permanenceMax</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a3bee602e490f27d510977bb7a37f8548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">resetCalled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This gets set when we receive a reset and cleared on the first compute following a reset. </p>

</div>
</div>
<a class="anchor" id="ab31f6ed1e7e88c7cca70910409c6bbee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">seed</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a6ab1e636c02cbb449d709ccbbbcb4277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">segmentUpdates</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We store the lists of segments updates, per cell, so that they can be applied later during learning, when the cell gets bottom-up activation. </p>
<p>We store one list per cell. The lists are identified with a hash key which is a tuple (column index, cell index). </p>

</div>
</div>
<a class="anchor" id="a001c511d4dcaf944615d26deae86ae94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">segUpdateValidDuration</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a97b1cc04ec204ba7f1507498beb1d460"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">verbosity</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<a class="anchor" id="a4c7a521b8f1a0769c09bfa4a1fca7dab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">version</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>document </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/nupic/research/<a class="el" href="_t_p_8py.html">TP.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Feb 21 2017 16:04:09 for NuPIC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
